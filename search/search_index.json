{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paraxial.io Documentation","text":"<p>Welcome to the Paraxial.io documentation. To begin securing your application, consult the Getting Started guide that matches your language:</p> <p>Getting Started with Paraxial.io for Elixir</p> <p>Getting Started with Paraxial.io for Ruby</p>"},{"location":"free_tier_faq/","title":"Free Tier FAQ","text":"<p>If you have questions about Paraxial, need enterprise support, or would like to upgrade your plan, email <code>support@paraxial.io</code>.</p> <p>Q: Can I use the free tier for my business?</p> <p>A: That is considered commercial use, you will have to purchase a license. </p> <p></p> <p>Q: What are the free tier limits?</p> <p>A: </p> <ol> <li>Maximum of 1 Site.</li> <li>You cannot invite users to a Site.</li> <li>No Bot Defense</li> <li>Limit of 5 scans per site, per month.</li> <li>No automated network scanning (daily, weekly)</li> </ol> <p></p> <p>Q: Can I open multiple free tier accounts for my different projects?</p> <p>A: Individuals may only open one free tier account. Creating multiple accounts for one person is a Terms of Service violation. </p>"},{"location":"network_scans/","title":"Network Scans","text":"<p>Before starting with network scans, determine if your application is hosted on a server where you control which ports are exposed to the public internet, or a Platform as a Service (PaaS).</p> <p>PaaS: Heroku, Render, Fly.io, Railway, Gigalixir </p> <p>VPS: AWS, GCP, Hetzner, Azure, Digital Ocean </p> <p>If your hosting provider is in the \"PaaS\" group, network scanning is not applicable to your application, because you don't have access to the host operating system and network configuration. If you are on a VPS, then using network scanning is recommended. </p> <p>If you cannot verify your site due to a DNS issue with your domain provider, email <code>support@paraxial.io</code> for help. </p>"},{"location":"network_scans/#setup","title":"Setup","text":"<p>To get started, create your site and go to the \"Network Scans\" page:</p> <p></p> <p>The Server URL value does not have to match the name of the site. To verify that you own the URL being scanned, you have to create a DNS TXT record for <code>paraxial-verification=your_value_here</code>. If the URL being scanned is a sub-domain, you will have to create the TXT record on that subdomain. For example:</p> <p>https://app.blackcatprojects.xyz/</p> <p>I'm using Namecheap as a domain provider, your settings may be different:</p> <p></p> <p>To verify that the DNS record has been updated, you can run:</p> <p><code>$ dig TXT app.blackcatprojects.xyz</code></p> <pre><code>@ parax_aws % dig TXT app.blackcatprojects.xyz\n...\n\n;; ANSWER SECTION:\napp.blackcatprojects.xyz. 1799  IN  TXT \"paraxial-verification=d2ca57cc7e73870f11d8b78ca2fb9a86\"\n\n...\n</code></pre> <p>Note that it may take a few minutes. Once the record is set you can run your first scan:</p> <p></p> <p>A scan takes 10 - 15 minutes to run, because it is checking all open ports. The results will be displayed in the Network Scans tab:</p> <p></p> <p>Setup the Slack App to receive the scan results in your designated channel:  </p> <p></p>"},{"location":"network_scans/#faq","title":"FAQ","text":"<p>Q: What ports should be exposed to the public internet? </p> <p>For most applications, you only want to have ports 80 and 443 exposed to the public internet, with port 22 only accessible on your home IP address. This is not always feasible, and if SSH must be accessible to the public internet, it is recommended that you only use public key authentication, because it reduces the risk of you accidentally using a weak password. The article Security Best Practices for Deploying Rails 8 on Linux with Kamal on the Paraxial.io blog goes into more detail on these best practices. </p> <p></p> <p>Q: When do the daily and weekly scans run?</p> <p>Daily scans run at 6pm UTC (1pm EST)</p> <p>Weekly scans run every Tuesday at 7pm UTC (2pm EST)</p> <p></p> <p>Q: What if my domain provider does not allow me to set the TXT record?</p> <p>Email <code>support@paraxial.io</code> for help.</p>"},{"location":"slack_app/","title":"Slack App","text":""},{"location":"slack_app/#alerts","title":"Alerts","text":"<p>The Slack App alerts on the following:</p> <ol> <li> <p>IP Bans to a rule match. For example, <code>IP sent &gt; 5 requests in 10 seconds to /users/login</code></p> </li> <li> <p>IP Ban due to a honeypot form being submitted. </p> </li> <li> <p>Exploit Guard triggered (monitor or block mode). </p> </li> <li> <p>Network Scan completed. </p> </li> </ol>"},{"location":"slack_app/#install","title":"Install","text":"<p>You will need permission to approve apps in your Slack workspace. Before installing the app, create a new channel where the alerts will be sent. The channel is named <code>paraxial_alerts</code> in this example</p> <p>Before installing, ensure the Paraxial.io user doing the install is a <code>site admin</code> on all sites you want to receive alerts for. If you are only a <code>site user</code>, that site will not send Slack notifications. This information is available in \"site settings\". </p>"},{"location":"slack_app/#install_1","title":"Install","text":""},{"location":"slack_app/#1-user-settings","title":"1. User Settings","text":""},{"location":"slack_app/#2-add-to-slack","title":"2. Add to Slack","text":""},{"location":"slack_app/#3-successful-install","title":"3. Successful Install","text":""},{"location":"slack_app/#4-user-settings","title":"4. User Settings","text":""},{"location":"slack_app/#5-test-message-sent-successfully","title":"5. Test Message Sent Successfully","text":""},{"location":"elixir/CHANGELOG/","title":"Paraxial.io Changelog","text":"<p>The Paraxial.io Elixir Agent is hosted on Hex - https://hex.pm/packages/paraxial</p>"},{"location":"elixir/CHANGELOG/#284","title":"<code>2.8.4</code>","text":"<ul> <li>Fix a bug in dependency scanning where the finding was not valid.</li> </ul>"},{"location":"elixir/CHANGELOG/#283","title":"<code>2.8.3</code>","text":"<ul> <li>Fix a bug in dependency parsing that led to scan failure. </li> </ul>"},{"location":"elixir/CHANGELOG/#282","title":"<code>2.8.2</code>","text":"<ul> <li>Add <code>.paraxial-ignore-deps</code> file to ignore dependency findings. See Code Scans for more information.</li> </ul>"},{"location":"elixir/CHANGELOG/#281","title":"<code>2.8.1</code>","text":"<ul> <li>Add the <code>--quiet-no-issues</code> flag for use with <code>--github_app</code>. A GitHub comment is no longer created when a scan returns 0 findings. </li> </ul>"},{"location":"elixir/CHANGELOG/#280","title":"<code>2.8.0</code>","text":"<ul> <li>Add <code>ban_ip/3</code> and <code>Paraxial.PHPAttackPlug</code></li> <li>Print the Paraxial agent version on startup and when running <code>mix paraxial.scan</code></li> </ul>"},{"location":"elixir/CHANGELOG/#278","title":"<code>2.7.8</code>","text":"<ul> <li>Add GitLab app.</li> </ul>"},{"location":"elixir/CHANGELOG/#277","title":"<code>2.7.7</code>","text":"<ul> <li><code>:paraxial_url</code> is no longer required in the config file.</li> <li>Warn when a <code>.sobelow_skips</code> file exists, but is not being read because <code>--sobelow-skip</code> was not passed.</li> <li>Do not send HTTP events to backend on free tier. </li> </ul>"},{"location":"elixir/CHANGELOG/#276","title":"<code>2.7.6</code>","text":"<ul> <li>Add <code>Paraxial.check_rate/6</code> for rate limiting with Paraxial.io reporting. Can be used to rate limit LiveView functions. </li> </ul>"},{"location":"elixir/CHANGELOG/#275","title":"<code>2.7.5</code>","text":"<ul> <li>Send the <code>conn.host</code> value to backend.</li> </ul>"},{"location":"elixir/CHANGELOG/#274","title":"<code>2.7.4</code>","text":"<ul> <li>Fix a bug where <code>mix paraxial.scan</code> with <code>--add-exit-code</code> and without <code>--github_app</code> would always return 1 (error). It now returns the correct value.</li> </ul>"},{"location":"elixir/CHANGELOG/#273","title":"<code>2.7.3</code>","text":"<ul> <li>Add a special check for the xz library, versions <code>5.6.0</code> and <code>5.6.1</code>, in App Audit. These versions have a high profile backdoor. </li> <li>Fix App Audit error where the agent is started without a config. </li> </ul>"},{"location":"elixir/CHANGELOG/#272","title":"<code>2.7.2</code>","text":"<ul> <li><code>mix paraxial.scan --no-license-scan</code>, the new flag will stop the license scan from running. </li> <li><code>mix paraxial.scan --add-exit-code</code> now returns 1 if an error condition occurs during the scan, for example the scan upload fails due to an invalid API key.</li> <li>If an invalid flag is passed to <code>mix paraxial.scan</code>, a warning is displayed. For example: <code>mix paraxial.scan --null</code> will show <code>[warning] [Paraxial] --null not a valid flag. Unexpected behavior may occur.</code></li> <li>Fix <code>function Mix.Dep.loaded/1 is undefined</code> for newer versions of Elixir <code>(&gt;= 1.16.0)</code></li> </ul>"},{"location":"elixir/CHANGELOG/#271","title":"<code>2.7.1</code>","text":"<ul> <li><code>File .sobelow-conf found, but --sobelow-config not set, default scan will run</code> - this is now a warning, not an error. </li> </ul>"},{"location":"elixir/CHANGELOG/#270","title":"<code>2.7.0</code>","text":"<ul> <li>Changes to <code>mix paraxial.scan</code>:</li> <li>The <code>--sobelow-config</code> flag is required to read <code>.sobelow-conf</code></li> <li>The <code>--sobelow-skip</code> flag is required to honor Sobelow skips (code comments or a <code>.sobelow-skips</code> file). Note that a <code>.sobelow-conf</code> files overrides this setting.</li> <li>The <code>--gpl-check</code> flag will create a vulnerability if a dependency using a GPL license is found.</li> <li>Add License Check, which uploads an inventory of dependencies taken at compile time with license info. This may result in different findings than App Audit (runtime) because the inventory is fetched at compile time. </li> </ul>"},{"location":"elixir/CHANGELOG/#264","title":"<code>2.6.4</code>","text":"<ul> <li>Add scan flags: <code>mix paraxial.scan --paraxial_url https://app.paraxial.io --paraxial_api_key API_KEY_HERE</code></li> <li>If these flags are set, they will override the config file values.</li> </ul>"},{"location":"elixir/CHANGELOG/#263","title":"<code>2.6.3</code>","text":"<ul> <li>Fix bug where <code>mix paraxial.scan</code> without <code>--sarif</code> flag crashed. </li> </ul>"},{"location":"elixir/CHANGELOG/#262","title":"<code>2.6.2</code>","text":"<ul> <li>Add <code>--sarif</code> flag to get enriched finding data.</li> </ul>"},{"location":"elixir/CHANGELOG/#261","title":"<code>2.6.1</code>","text":"<ul> <li>The Sobelow scan in <code>mix paraxial.scan</code> now has the <code>--config</code> flag by default, so it can read <code>.sobelow-conf</code>.</li> </ul>"},{"location":"elixir/CHANGELOG/#260","title":"<code>2.6.0</code>","text":"<ul> <li>Add the <code>mix paraxial.scan --github_app</code> flag, for use with the Paraxial.io Github App</li> <li>Additional required arguments: <code>--install_id</code>, <code>--repo_owner</code>, <code>--repo_name</code>, <code>--pr_number</code></li> <li>See the Github App page for installation instructions.</li> </ul>"},{"location":"elixir/CHANGELOG/#252","title":"<code>2.5.2</code>","text":"<ul> <li><code>mix paraxial.scan</code> prints scan uuid.</li> </ul>"},{"location":"elixir/CHANGELOG/#251","title":"<code>2.5.1</code>","text":"<ul> <li><code>iptrie</code> from <code>~&gt; 0.8.0</code> to <code>&gt;= 0.8.0</code>.</li> <li><code>sobelow</code> from <code>~&gt; 0.12.2</code> to <code>&gt;= 0.12.2</code>.</li> <li>Change <code>warn</code> to <code>error</code> to better reflect error conditions.</li> </ul>"},{"location":"elixir/CHANGELOG/#250","title":"<code>2.5.0</code>","text":"<ul> <li>Add App Audit to agent. </li> </ul>"},{"location":"elixir/CHANGELOG/#240","title":"<code>2.4.0</code>","text":"<ul> <li>Add Exploit Guard to agent.</li> </ul>"},{"location":"elixir/CHANGELOG/#234","title":"<code>2.3.4</code>","text":"<ul> <li><code>mix paraxial.scan</code> now has the <code>--add-exit-code</code> flag, returns unix exit code 1 if scan has findings. Returns 0 if no findings. </li> </ul>"},{"location":"elixir/CHANGELOG/#233","title":"<code>2.3.3</code>","text":"<ul> <li>Allow HTTPoison versions <code>2.0.0</code> and higher</li> </ul>"},{"location":"elixir/CHANGELOG/#232","title":"<code>2.3.2</code>","text":"<ul> <li>Upgrade Sobelow from <code>0.12.1</code> to <code>0.12.2</code></li> </ul>"},{"location":"elixir/CHANGELOG/#231","title":"<code>2.3.1</code>","text":"<ul> <li>Sobelow <code>0.12.0</code> required <code>castore</code> ~&gt; 1.0</li> <li>Sobelow <code>0.12.1</code> relaxes this requirement for backwards compatibility</li> </ul>"},{"location":"elixir/CHANGELOG/#230","title":"<code>2.3.0</code>","text":"<ul> <li>Upgrade Sobelow from <code>0.11.1</code> to <code>0.12.0</code></li> <li>Sobelow now checks for XSS in HEEx templates</li> </ul>"},{"location":"elixir/CHANGELOG/#220","title":"<code>2.2.0</code>","text":"<ul> <li><code>mix paraxial.scan</code> now supports umbrella projects. </li> <li>Requires you to add <code>sobelow: [\"cmd mix sobelow\"]</code> in your top-level mix file. https://github.com/nccgroup/sobelow/pull/108/files</li> </ul>"},{"location":"elixir/CHANGELOG/#210","title":"<code>2.1.0</code>","text":"<ul> <li>You can now disable the Paraxial.io agent. If there is no configuration set for <code>:paraxial_api_key</code> or <code>:paraxial_url</code>, the agent will not start, and the Paraxial plugs will do nothing to conn. </li> <li>To disable the agent in your <code>dev</code> or <code>test</code> environment, ensure there are no values set for your <code>:paraxial</code> configuration. If <code>:paraxial_api_key</code> and <code>:paraxial_url</code> have non-nil values, the agent will start and the Paraxial plugs will function normally. </li> </ul>"},{"location":"elixir/CHANGELOG/#200","title":"<code>2.0.0</code>","text":"<ul> <li>WARNING: Breaking changes to the <code>only/except</code> configuration values. Previously these were read via <code>Application.get_env</code>, and would not raise an error if runtime and compile time settings were different. </li> <li><code>only/except</code> are now read with <code>Application.compile_env/3</code> in <code>2.0.0</code>. From the docs, \"By using compile_env/3, tools like Mix will store the values used during compilation and compare the compilation values with the runtime values whenever your system starts, raising an error in case they differ.\"</li> <li>There is no change in features from <code>1.1.0</code> to <code>2.0.0</code>. The reason for this release is to make debugging CI/CD pipelines easier, because <code>compile_env</code> will trigger an error if runtime and compile time configuration differs. </li> <li>After changing <code>only/except</code> in your dev environment run <code>mix deps.clean paraxial</code>. If you don't, you will get an error, <code>ERROR! the application :paraxial has a different value set for key :except during runtime</code>.</li> </ul>"},{"location":"elixir/CHANGELOG/#110","title":"<code>1.1.0</code>","text":"<ul> <li>Add <code>mix paraxial.scan</code>, code scanning for vulnerabilities. </li> </ul>"},{"location":"elixir/CHANGELOG/#100","title":"<code>1.0.0</code>","text":"<ul> <li>If <code>fetch_cloud_ips</code> is set to true, and there is no internet connection, <code>ip_trie</code> will be set to an empty trie. </li> <li><code>PARAXIAL_API_KEY</code> environment variable support added. </li> </ul>"},{"location":"elixir/bot_defense/","title":"Bot Defense","text":"<p>Definitions</p> <p>Site - An Elixir/Phoenix/Plug web application that has the Paraxial agent installed and running. You create a site through the Paraxial web interface, provide the site API key to the Paraxial agent, and a connection is established between the Paraxial server and your application. A site has many rules, allowed IP addresses, banned IP address, and site members.</p> <p>Rule - A user defined condition such as, \"If one IP address sends &gt; 20 POST requests to <code>/users/log_in</code> in a period of 5 seconds, create an alert and ban the IP address.\" A benefit of Paraxial over traditional systems is that if an IP sending hundreds of requests per second, it will only be permitted to send 20 requests, the 21st will be banned. Compare this with a periodic database query, which would allow hundreds of requests before banning the client.</p> <p>Rule Event - When an IP address matches a rule, such as, \"If an IP sends &gt; 20 POST requests to <code>/users/log_in</code> in a period of 5 seconds, alert and ban\", a rule event is created. The rule event contains information about what caused the rule to be triggered.</p> <p>Allow List - A list of IP prefixes defined by the user. If an IP matches a prefix on this list, it will always be allowed through. Supports IPv4 and IPv6 prefixes.</p> <p>Ban List - Similar to Allow List, matching requests will never succeed. Supports IPv4 and IPv6 prefixes.</p> <p>Site Admin - Has full control over the site.</p> <p>Site User - Limited control over a site, for example this user cannot delete the site.</p>"},{"location":"elixir/bot_defense/#defining-rules","title":"Defining Rules","text":"<p>Paraxial.io allows users to define \"Rules\", which are conditions in their web application related to incoming HTTP traffic. The following are examples of rules:</p> <ol> <li> <p><code>If an IP sends &gt; 5 POST requests to /accounts/new_user in a 20 second period, create an alert.</code></p> </li> <li> <p><code>If an IP sends &gt; 10 requests of any HTTP method to /projects/*/export in a 12 second period, create an alert and ban the IP address.</code></p> </li> <li> <p><code>If an IP sends &gt; 100 requests of any HTTP method to any path in a 5 second period, ban the IP address.</code></p> </li> </ol> <p>The purpose of defining rules is to prevent a malicious client from sending an excessive number of unwanted requests. Some examples of requests that you may want to throttle may be related to:</p> <ul> <li>Login attempts</li> <li>New account creation</li> <li>Credit card transactions</li> <li>Email sending</li> <li>Expensive computation</li> <li>Excessive total requests (scraping, vulnerability scanning)</li> <li>Denial of service attacks</li> </ul> <p>To create a rule, navigate to:</p> <p><code>app.paraxial.io/site/:your_site/new_rule</code></p> <p>You should see a form that says <code>Create new rule for :your_site</code>, with some fields. These are:</p> <ol> <li><code>Rule name</code> - A user provided string, it should be a descriptive comment on what the rule intends to do.</li> <li><code>N requests</code> - The number of requests one IP address can make in the given time period before matching the rule.</li> <li><code>Time period in seconds</code> - If you wish to limit login requests to 10 every 5 seconds, this value should be 5.</li> <li><code>Path</code> - The path of the incoming request. Uses a custom pattern matching language detailed below.</li> <li><code>HTTP Methods</code> - Examples include GET, PUT, POST. Uses a custom pattern matching language detailed below.</li> <li><code>On trigger</code> - When the rule is matched, you may create an alert, ban the IP, or do both.</li> </ol> <p>Example Rule Creation</p> <p>To create the rule <code>If an IP sends &gt; 5 POST requests to /accounts/new_user in a 20 second period, create an alert and ban the IP address</code>, the following form values are used:</p> <ol> <li> <p><code>Rule name</code> - This is an arbitrary value, written to be understood by users of Paraxial.io. You could name this \"Alert and ban on excessive logins in short period\", or \"ATO &gt; 5 in 20s to /accounts/new_user\". The behavior of the rule is independent of this string, similar to comments in a programming language. </p> </li> <li> <p><code>N requests</code> - <code>5</code></p> </li> <li> <p><code>Time period in seconds</code> - <code>20</code></p> </li> <li> <p><code>Path</code> - <code>/accounts/new_user</code> - This must be entered exactly as provided here. If your value does not start with a <code>/</code>, it will be rejected. More details are below on how path matching works.</p> </li> <li> <p><code>HTTP Methods</code> - <code>POST</code> - This must be entered exactly as provided here. More details on http method matching below.</p> </li> <li> <p><code>On trigger</code> - <code>Create an alert and ban the IP</code></p> </li> </ol> <p></p> <p>Field Details</p> <p>N requests <code>N requests</code> must be &gt; 0 and &lt; 999. </p> <p>Time period in seconds <code>Time period in seconds</code> must be &gt; 0 and &lt; 86,400.</p> <p>Path The \"Path\" field uses a custom language for matching on paths. Examples are:</p> <p>Path <code>*</code> - Match any path.</p> <p>Matching:</p> <pre><code>paraxial.io/new_user\nparaxial.io/site/paraxial.io/settings\nparaxial.io/site/paraxial.io/edit_users/update\n</code></pre> <p>Path <code>/new_user</code> - Only matching incoming requests for the route <code>new_user</code>.</p> <p>Matching:</p> <pre><code>paraxial.io/new_user\nparaxial.io/new_user/\nparaxial.io/new_user//\nparaxial.io/new_user///\n</code></pre> <p>Will not match:</p> <pre><code>paraxial.io/new_user/a/new_user\nparaxial.io/new_user/!\nparaxial.io/new_user/a\n</code></pre> <p>Path <code>/site/*/settings</code> - Matching incoming requests for the route <code>/site/:any_value/settings</code>.</p> <p>Matching:</p> <pre><code>paraxial.io/site/paraxial.io/settings\nparaxial.io/site/paraxial.io/settings/\nparaxial.io/site/customsitehere.com/settings\nparaxial.io/site/customsitehere.com/settings/\n</code></pre> <p>Will not match:</p> <pre><code>paraxial.io/site/paraxial.io\nparaxial.io/site/paraxial.io/settings/edit_users\n</code></pre> <p>Path <code>/site/*/settings/*</code> - Matching incoming requests for the route <code>/site/:any_value/settings/:any_value</code>.</p> <p>Matching:</p> <pre><code>paraxial.io/site/paraxial.io/edit_users\nparaxial.io/site/paraxial.io/list_users\n</code></pre> <p>Will not match:</p> <pre><code>paraxial.io/site/paraxial.io/edit_users/update\nparaxial.io/site/paraxial.io\n</code></pre> <p></p> <p>HTTP Methods</p> <p>The <code>HTTP Methods</code> field takes a list of comma separated HTTP method names, such as: </p> <p><code>GET, POST, PUT</code></p> <p>for use in rule matching. It also supports the wildcard <code>*</code> character, to match all HTTP methods. These are:</p> <p><code>GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH</code></p> <p>To match all HTTP methods, input: <code>*</code></p> <p>To match GET only, input: <code>GET</code></p> <p>To match GET and POST, input: <code>GET, POST</code></p> <p>To match GET, POST, and PUT, input: <code>GET, POST, PUT</code></p> <p></p> <p>Rule Events The rule events page lists useful information about why an IP address matched a rule. This includes:</p> <ol> <li>The rule that was matched</li> <li>How many requests the IP sent in the rule time period</li> <li>If the IP is currently on the allow or ban lists</li> <li>Associated login attempts from the IP, if <code>paraxial_login_user_name</code> and <code>paraxial_login_success</code> assigns are in use by your application</li> <li>The matching HTTP requests, with timestamps  </li> </ol> <p></p> <p>Allow/Block List The IP block and allow lists support IPv4 and IPv6 prefixes. Examples include:</p> <ul> <li><code>3.5.140.0/22</code></li> <li><code>2600:1f14:fff:f800::/56</code></li> </ul>"},{"location":"elixir/bot_defense/#exclude-data-collection-for-specific-routes","title":"Exclude data collection for specific routes","text":"<p>The pricing on Paraxial.io is by the number of good events sent by the agent to the backend. A good event means one HTTP request sent to your web app. So if 5 users send a total of 50 requests, that's 50 good events. If a spammer sends 5,000 blocked requests, those don't count. By default, the agent sends all HTTP requests to the backend.</p> <p>To only collect data for specific routes, set your configuration at compile time to the code below, by editing your <code>config/dev.exs</code>, <code>config/test.exs</code>, and <code>config/prod.exs</code> files. </p> <p>Do NOT set <code>only:</code> or <code>except:</code> at runtime, the agent uses metaprogramming to generate code at compile time. If you set <code>only:</code> or <code>except:</code> at runtime, the agent will ignore the config and send data for all routes. As of <code>2.0.0</code>, you will get an error (see below).</p> <p>To have the agent only send data to the backend for the following:</p> <ul> <li>GET /users/log_in</li> <li>POST /users/log_in</li> <li>GET /users/:id/settings</li> </ul> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),  \n  ... \n  only: [\n    %{path: \"/users/log_in\", method: \"GET\"},\n    %{path: \"/users/log_in\", method: \"POST\"},\n    %{path: \"/users/:id/settings\", method: \"POST\"}\n  ]\n</code></pre> <p>To send events for all routes, except the following:</p> <ul> <li>GET /health_check</li> <li>GET /users/:id/status</li> </ul> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),  \n  ... \n  except: [\n    %{path: \"/health_check\", method: \"GET\"},\n    %{path: \"/users/:id/status\", method: \"GET\"}\n  ]\n</code></pre> <p>After changing <code>only/except</code> in your compile time configuration, you must run:</p> <pre><code>mix deps.compile paraxial --force\n</code></pre> <p>Or you will get an error:</p> <pre><code>@ air % mix phx.server\nERROR! the application :paraxial has a different value set for key :except during runtime compared to compile time. Since this application environment entry was marked as compile time, this difference can lead to different behaviour than expected:\n\n  * Compile time value was not set\n  * Runtime value was set to: [%{method: \"GET\", path: \"/health_check\"}, %{method: \"GET\", path: \"/users/:id/status\"}]\n\nTo fix this error, you might:\n\n  * Make the runtime value match the compile time one\n\n  * Recompile your project. If the misconfigured application is a dependency, you may need to run \"mix deps.compile paraxial --force\"\n\n  * Alternatively, you can disable this check. If you are using releases, you can set :validate_compile_env to false in your release configuration. If you are using Mix to start your system, you can pass the --no-validate-compile-env flag\n</code></pre> <p>Note that you should only define rules for routes that have collection enabled. If you define a rule for a route, but disable collection for it, the rule will not work correctly. </p> <p>If an attacker is banned due to triggering a rule, the attacker will be banned from all routes in your application, even if collection is not enabled for those routes.</p>"},{"location":"elixir/bot_defense/#liveview","title":"LiveView","text":"<ul> <li>In a LiveView app, you want to rate limit an action that is triggered via a websocket </li> <li>In a Phoenix app with multiple endpoints, you want to rate limit requests with a specific <code>conn.host</code>. </li> </ul> <p>Paraxial.io agent <code>2.7.6</code> introduced the <code>Paraxial.check_rate/6</code> function for these use cases. For example:</p> <pre><code>def handle_event(\"login\", %{\"user\" =&gt; user_params}, socket) do\n  ip_string = socket.assigns.address |&gt; :inet.ntoa() |&gt; to_string()\n  key = \"user-login-#{ip_string}\"\n  seconds = 5\n  count = 5\n  ban_length = \"hour\"\n  ip = socket.assigns.address\n  msg = \"`&gt; 5 requests in 5 seconds to login from #{ip_string}`\"\n\n  case Paraxial.check_rate(key, seconds, count, ban_length, ip, msg) do\n    {:allow, _} -&gt;\n      do_handle_login(user_params)\n    {:deny, _} -&gt; \n      conn\n      |&gt; put_resp_content_type(\"text/html\")\n      |&gt; send_resp(429, \"Rate limited\")\nend\n</code></pre> <p>It is recommended to keep the <code>seconds</code> value under 60 to avoid excessive memory usage. In the above example the rate limiting key is the incoming IP address. This could also be changed to include the <code>conn.host</code> value, user email, or any value you would like to rate limit on. </p> <p>The main benefit of this rate limiting over using an open-source version is the banning of IPs will be tracked on the Paraxial.io backend. You can also receive an alert when the rule is triggered via the Paraxial.io Slack App:</p> <p></p> <p><code>Paraxial.check_rate(key, seconds, count, ban_length, ip, msg)</code></p> <p>Rate limiter that will also ban the relevant IP address via Paraxial.io.</p> <p>Returns <code>{:allow, n} or {:deny, n}</code></p> <ul> <li><code>key: String to rate limit on, ex: \"login-96.56.162.210\", \"send-email-michael@paraxial.io\"</code></li> <li><code>seconds: Length of the rate limit rule</code></li> <li><code>count: Number of times the action can be performed in the seconds time limit</code></li> <li><code>ban_length: Valid strings are \"alert_only\", \"hour\", \"day\", \"week\", \"infinity\"</code></li> <li><code>ip: Tuple, you can pass conn.remote_ip directly here</code></li> <li><code>msg: Human-readable string, ex: \"&gt; 5 requests in 10 seconds to blackcatprojects.xyz/users/log_in from \\#{ip}\"</code></li> </ul> <pre><code>ip_string = conn.remote_ip |&gt; :inet.ntoa() |&gt; to_string()\nkey = \"user-register-get-\\#{ip_string}\"\nseconds = 5\ncount = 5\nban_length = \"hour\"\nip = conn.remote_ip\nmsg = \"&gt; 5 requests in 10 seconds to \\#{conn.host}/users/log_in from \\#{ip_string}\"\n\ncase Paraxial.check_rate(key, seconds, count, ban_length, ip, msg) do\n  {:allow, _} -&gt;\n    # Allow code here\n  {:deny, _} -&gt;\n    conn\n    |&gt; put_resp_content_type(\"text/html\")\n    |&gt; send_resp(401, \"Banned\")\nend\n</code></pre>"},{"location":"elixir/bot_defense/#paraxial-plugs","title":"Paraxial Plugs","text":"<p>The Paraxial.io Agent provides several Plugs to be used in your application code:</p> <ol> <li> <p><code>Paraxial.AllowedPlug</code> - Required, this Plug determines if an incoming requests matches your allow/block lists. If a request is halted by this Plug, internally Paraxial will still record it. </p> </li> <li> <p><code>Paraxial.RecordPlug</code> - Required, records incoming HTTP requests into a local buffer, then sends them to the Paraxial.io backend.</p> </li> <li> <p><code>Paraxial.AssignCloudIP</code> - Optional, if the <code>remote_ip</code> of an incoming request matching a cloud provider IP address, this plug will add metadata to the conn via an assigns. For example, if a conn's remote_ip matches aws, this plug will do <code>assigns(conn, :paraxial_cloud_ip, :aws)</code>.</p> </li> <li> <p><code>Paraxial.BlockCloudIP</code> - Optional, similar to AssignCloudIP. When a conn matches a cloud provider IP, the assign is updated and the conn is halted, with a 404 response sent to the client. </p> </li> <li> <p><code>Paraxial.CurrentUserPlug</code> - Optional, only works if <code>conn.assigns.current_user.email</code> is set. Sets the :paraxial_current_user assigns by calling <code>assign(conn, :paraxial_current_user, conn.assigns.current_user.email)</code></p> </li> </ol>"},{"location":"elixir/bot_defense/#assigns","title":"Assigns","text":"<p>This is a table of every Paraxial assigns value. To avoid conflict with assigns in your application code, each assigns key is prefixed with <code>paraxial</code>. </p> Key Set By Type :paraxial_login_success User Application Boolean :paraxial_login_user_name User Application String :paraxial_current_user User Application String :paraxial_cloud_ip Paraxial Agent String (aws, azure, etc.) <p>To monitor login attempts, use:</p> <pre><code>assign(conn, :paraxial_login_success, true/false)\n</code></pre> <p>To monitor the login name for the given login attempt use:</p> <pre><code>assign(conn, :paraxial_login_user_name, \"userNameHere\")\n</code></pre> <p>To map incoming requests to the currently logged in user, use:</p> <pre><code>assign(conn, :paraxial_current_user, \"userNameHere\")\n</code></pre> <p>The <code>:paraxial_cloud_ip</code> assign is set by <code>Paraxial.AssignCloudIP</code>. If you do not use this assign anywhere in your application code, and just want to block cloud IPs, use <code>Paraxial.BlockCloudIP</code>. Check your configuration to ensure <code>fetch_cloud_ips: true</code> is set. </p>"},{"location":"elixir/bot_defense/#using-the-paraxial-assigns","title":"Using the Paraxial Assigns","text":"<p>The Paraxial agent allows you to collect information about which IP addresses are attempting to login in to which accounts in your application, and if those logins were successful. This is possible by setting two values in your conn assigns, <code>:paraxial_login_success</code> and <code>:paraxial_login_user_name</code>.</p> <p>The code below was generated using the mix auth generator, however your application may require setting these values in different locations. The example below is given to illustrate how to set the assigns. </p> <pre><code>conn = assign(conn, :paraxial_login_user_name, email)\nconn = assign(conn, :paraxial_login_success, true)\nconn = assign(conn, :paraxial_login_success, false)\n</code></pre> <p></p> <p></p>"},{"location":"elixir/bot_defense/#debug","title":"Debug","text":"<p>The majority of Phoenix applications do this by default. Check your <code>endpoint.ex</code> file for the line:</p> <pre><code>  plug Plug.RequestId\n</code></pre> <p>This plug sets <code>x-request-id</code>, which is required for the Paraxial agent to work correctly. If it does not exist, add it to your project. </p> <p>Set your application's local logging level to debug. This will allow you to see debug messages from the Paraxial agent. Example <code>config/dev.exs</code>:</p> <pre><code>config :logger, level: :debug\n</code></pre>"},{"location":"elixir/bot_defense/#faq","title":"FAQ","text":"<p>Do my users need to wait for a round trip network connection because of Paraxial.io?</p> <p>No, the analysis takes place in the agent, there is no round-trip network connection required. </p> <p></p> <p>What happens in my application if the Paraxial.io agent cannot communicate with the Paraxial.io backend?</p> <p>The agent will fail open, so your application will continue to function as it normally would without the agent installed. </p> <p></p> <p>How long is my site's data stored?</p> <p>Seven days, after which it is automatically deleted. </p>"},{"location":"elixir/code_scans/","title":"Code Scans","text":""},{"location":"elixir/code_scans/#flags","title":"Flags","text":"<p>Command line flags for <code>mix paraxial.scan</code>:</p> <p><code>--add-exit-code</code> - Return unix exit code 1 if a scan has findings, 0 if no findings. Useful in CI/CD pipelines to fail when findings are detected. Also returns 1 if an error occurs. </p> <p><code>--sobelow-config</code> - If you would like to use a <code>.sobelow-conf</code> file, this flag is required to read it. By default, the file is ignored. </p> <p><code>--sobelow-skip</code> - Required to skip Sobelow findings. Note that a <code>.sobelow-conf</code> file being used overrides this setting.</p> <p><code>--gpl-check</code> - Create a vulnerability if a dependency using a GPL license is found.</p> <p><code>--no-license-scan</code> - Do not perform the license scan that occurs automatically. </p> <p><code>--paraxial_url</code> - Optional, Paraxial url as a cli flag instead of the config value. </p> <p><code>--paraxial_api_key</code> - Optional, Paraxial API key as a cli flag instead of the config value. </p> <p><code>--sarif</code> - Output findings in SARIF format. </p> <p><code>--github_app</code> - Used to create PR comments in GitHub. See the <code>GitHub App</code> page for full details.</p> <p><code>--install_id</code> - GitHub App, the install ID in your GitHub account</p> <p><code>--repo_owner</code> - GitHub App, repo owner name</p> <p><code>--repo_name</code> - GitHub App, repo name</p> <p><code>--pr_number</code> - GitHub App, PR number</p> <p><code>--quiet-no-issues</code> - GitHub App, a GitHub comment is no longer created when a scan returns 0 findings. </p>"},{"location":"elixir/code_scans/#umbrella-applications","title":"Umbrella Applications","text":"<p>To use <code>mix paraxial.scan</code> with your Umbrella application, you must update the <code>aliases</code> functions in the top level <code>mix.exs</code> file to include:</p> <pre><code>defp aliases do\n  [\n    sobelow: [\"cmd mix sobelow\"]\n  ]\nend\n</code></pre> <p>This is to run Sobelow against all child applications. </p>"},{"location":"elixir/code_scans/#ignore-dependencies","title":"Ignore Dependencies","text":"<p>This features requires Paraxial.io Elixir version <code>2.8.2</code> or later. </p> <p>To ignore a dependency related finding in Paraxial.io code scans:</p> <ol> <li>Create the file <code>.paraxial-ignore-deps</code> in your project directory</li> <li>Add the name of each dependency you want to ignore on a new line</li> </ol> <p>Example:</p> <pre><code>% cat .paraxial-ignore-deps \nhackney \njason\nremote_ip\n\n</code></pre> <p>Sample output:</p> <pre><code>% mix paraxial.scan        \n\n16:53:49.918 [info] [Paraxial] v2.8.3, scan starting\n16:53:49.920 [info] [Paraxial] API key found, scan results will be uploaded\n16:53:50.840 [info] [Paraxial] Ignoring dependencies listed in .paraxial-ignore-deps\n[Paraxial] .paraxial-ignore-deps list: [\"hackney\", \"jason\", \"remote_ip\"]\n...\n</code></pre>"},{"location":"elixir/github_app/","title":"GitHub App","text":"<p>This guide to installing the Paraxial.io GitHub App assumes you are using GitHub Actions for CI/CD. The app is compatible with other providers (CircleCI, etc). </p> <p>For an overview of why the GitHub App is useful, see the blog post Introducing the Paraxial.io GitHub App</p>"},{"location":"elixir/github_app/#1-create-a-paraxialio-site-install-the-agent","title":"1. Create a Paraxial.io site, install the agent","text":"<p>Why install the Paraxial.io agent locally if the goal is to run the Github app in CI/CD? This is for developer experience and happiness. A CI run can take minutes to complete, and the cycle of \"make a code change, wait several minutes for CI to finish\" slows down developer productivity. By running the check locally, the debugging loop is much faster. </p> <p>Note: You MUST use version <code>2.6.3</code> or later. Earlier versions do not support the GitHub App.</p> <p><code>mix.exs</code></p> <pre><code>{:paraxial, \"~&gt; 2.8.4\"}\n</code></pre> <pre><code>mix deps.get\n</code></pre> <p>Install the Paraxial.io agent in <code>mix.exs</code>, then configure <code>dev.exs</code> and <code>prod.exs</code>.</p> <pre><code>config/dev.exs\n\nconfig :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\")\n</code></pre> <pre><code>config/prod.exs\n\nconfig :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\")\n</code></pre> <p>For the GitHub app we really only need <code>dev.exs</code>, however the reason you want this in both environments is for the additional runtime protection features of Paraxial.io. </p> <p>Set the environment variable in your terminal with:</p> <p><code>$ export PARAXIAL_API_KEY=df90...redacted...</code></p> <p>This key is found in the \"Site Settings\" page. Now run:</p> <pre><code>% mix deps.compile\n% mix paraxial.scan\n13:35:00.130 [info]  [Paraxial] API key found, scan results will be uploaded\n...\n13:35:01.905 [info]  [Paraxial] Scan written successfully. UUID 4b6a5fe3-626a-46e5-a959-6008f6114a74\n</code></pre> <p>This confirms Paraxial.io is installed and working locally. </p>"},{"location":"elixir/github_app/#2-install-the-paraxialio-github-app-get-the-install_id","title":"2. Install the Paraxial.io GitHub App, get the install_id.","text":"<p>The Paraxial.io App can be installed in an organization or individual account. GitHub Marketplace - https://github.com/marketplace/paraxial-io</p> <p></p> <p>Note the install_id of <code>45554672</code>. Your value will be different. Make a note of this value somewhere, you will need it later.</p> <p>The Paraxial.io Github App is compatible with all CI/CD pipelines. We will be using a Github Action in this example. The following is required:</p> <ol> <li>Paraxial.io App Install ID (<code>45554672</code> in this example, your value will be different)</li> <li>Repo Owner</li> <li>Repo Name</li> <li>Pull Request number</li> </ol> <p>The dynamic values should be accessible in your CI environment. </p>"},{"location":"elixir/github_app/#3-put-the-paraxialio-api-key-in-github-actions-secrets","title":"3. Put the Paraxial.io API key in GitHub Actions Secrets","text":"<p>This secret key is found in \"Site Settings\" in the Paraxial.io web interface. </p> <p> </p>"},{"location":"elixir/github_app/#4-configure-the-github-action","title":"4. Configure the GitHub Action","text":"<p>Before continuing, answer the following questions:</p> <p></p> <p>Q: What is the name of your repo's primary branch? (It is probably <code>master</code> or <code>main</code>) </p> <p>If your repo's branch is different, replace the \"branches\" value.</p> <p>Q: If Paraxial.io detects security problems, do you want the build to fail? </p> <p>If you do not want the build to fail when security issues are detected, remove the <code>--add-exit-code</code> flag. </p> <p>Q: What is your Paraxial.io Github App Install ID? </p> <p>See the section above </p> <p></p> <p>GitHub Action:</p> <p><code>.github/workflows/elixir.yml</code></p> <pre><code>name: Paraxial.io Application Secure\n\non:\n  push:\n    branches: [ \"master\" ]\n  pull_request:\n    branches: [ \"master\" ]\n\npermissions:\n  contents: read\n\njobs:\n  build:\n\n    name: Build and test\n    runs-on: ubuntu-latest\n\n    env:\n      PARAXIAL_API_KEY: ${{ secrets.PARAXIAL_API_KEY }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Elixir\n      uses: erlef/setup-beam@61e01a43a562a89bfc54c7f9a378ff67b03e4a21 # v1.16.0\n      with:\n        elixir-version: '1.15.2' # [Required] Define the Elixir version\n        otp-version: '26.0'      # [Required] Define the Erlang/OTP version\n    - name: Restore dependencies cache\n      uses: actions/cache@v3\n      with:\n        path: deps\n        key: ${{ runner.os }}-mix-${{ hashFiles('**/mix.lock') }}\n        restore-keys: ${{ runner.os }}-mix-\n\n    - name: Install dependencies\n      run: mix deps.get\n\n    - name: Compile dependencies\n      run: mix deps.compile\n\n    - name: Get Github Repo Name\n      run: echo \"REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)\" &gt;&gt; $GITHUB_ENV\n\n    - name: Paraxial.io Scan, pull request does not exists\n      if: \"${{ github.event.number == '' }}\"\n      run: |\n        mix paraxial.scan --sobelow-config --add-exit-code\n\n    - name: Paraxial.io Scan, pull request exists \n      if: \"${{ github.event.number != '' }}\"\n      run: |\n        mix paraxial.scan --github_app \\\n          --install_id REPLACE_THIS_VALUE \\\n          --repo_owner ${{ github.repository_owner }} \\\n          --repo_name ${{ env.REPO_NAME }} \\\n          --pr_number ${{ github.event.number }} \\\n          --sobelow-config \\\n          --add-exit-code\n</code></pre> <p>Example of a successful run:</p> <pre><code>  mix paraxial.scan --github_app \\\n    --install_id 45233668 \\\n    --repo_owner realcorvus \\\n    --repo_name priv_potion_shop \\\n    --pr_number 25 \\\n    --add-exit-code\n  shell: /usr/bin/bash -e {0}\n  env:\n    PARAXIAL_API_KEY: ***\n    INSTALL_DIR_FOR_OTP: /opt/hostedtoolcache/otp/ubuntu-22.04/OTP-26.0.2/x64\n    INSTALL_DIR_FOR_ELIXIR: /opt/hostedtoolcache/elixir/1.15.2-otp-26/x64\n    REPO_NAME: priv_potion_shop\n\n18:20:28.518 [info] [Paraxial] API key found, scan results will be uploaded\n[Paraxial] Scan findings: %Paraxial.Scan{\n  timestamp: ~U[2024-01-01 18:20:30.840501Z],\n  findings: [\n    %Paraxial.Finding{\n      source: \"sobelow\",\n      content: %{\n        \"confidence\" =&gt; \"high_confidence\",\n        \"file\" =&gt; \"lib/carafe_web/controllers/potion_controller.ex\",\n        \"line\" =&gt; 29,\n        \"type\" =&gt; \"Misc.BinToTerm: Unsafe `binary_to_term`\",\n        \"variable\" =&gt; \"cursor_bin\"\n      }\n  ...\n  api_key: \"REDACTED\"\n}\n[Paraxial] Github Upload info: %{\n  \"api_key\" =&gt; \"REDACTED\",\n  \"installation_id\" =&gt; \"45233668\",\n  \"pull_request_number\" =&gt; \"25\",\n  \"repository_name\" =&gt; \"priv_potion_shop\",\n  \"repository_owner\" =&gt; \"realcorvus\",\n  \"scan_uuid\" =&gt; \"e381fb5b-af18-4abc-b782-3c7acda6368d\"\n}\n\n18:20:31.205 [info] [Paraxial] Scan written successfully. UUID e381fb5b-af18-4abc-b782-3c7acda6368d\n\n18:20:31.205 [info] [Paraxial] Github App Correct Arguments\n\n18:20:33.148 [info] [Paraxial] Github PR Comment Created successfully\n\n18:20:33.148 [info] [Paraxial] URL: (Pull request url here)\nError: Process completed with exit code 1.\n</code></pre> <p>Troubleshooting:</p> <ol> <li>What version of the Paraxial.io agent is running in CI/CD? Check your lock file. You must use version <code>2.6.3</code> or later for the GitHub App to work.</li> </ol>"},{"location":"elixir/github_app/#5-open-a-pull-request","title":"5. Open a Pull Request","text":"<p>You should have completed the following by now:</p> <ol> <li> <p>Installed the Paraxial.io GitHub App</p> </li> <li> <p>Configured <code>mix paraxial.scan --github_app</code> to run in CI/CD</p> </li> <li> <p>Put the correct Paraxial.io Site API Key into the CI/CD pipeline</p> </li> </ol> <p>To use the Paraxial.io app, open a pull request:</p> <p></p> <p>If no issues are found, you will get a green check comment:</p> <p></p>"},{"location":"elixir/gitlab_app/","title":"GitLab App","text":""},{"location":"elixir/gitlab_app/#1-prerequisites","title":"1. Prerequisites","text":"<p>Before starting with the GitLab App, ensure that Paraxial.io is setup. For example, you should be able to run:</p> <p><code>mix paraxial.scan</code></p> <p>And view the results of this scan in the web interface. If you have not completed this setup, go the getting started guide and complete that first before continuing. </p> <p>If you can see recent events for \"Vulnerabilities\" in your site's overview page, then continue:</p> <p></p>"},{"location":"elixir/gitlab_app/#2-gitlab-api-token","title":"2. GitLab API token","text":"<p>You will need to create a GitLab access token. This may be:</p> <ul> <li>A personal access token</li> <li>A project access token (requires Maintainer role)</li> <li>A group access token (requires Maintainer role)</li> </ul> <p>The access token you create must have the <code>api</code> and <code>write_repository</code> scopes. If you are creating a project or group token, ensure the role is Maintainer, or else the token may not work. It should have the format: <code>glpat-Yhg[redacted]</code></p> <p>It can be frustrating to create a token and place it in CI/CD, only to learn that the incorrect scope or role was set. To ensure the token is working before continuing, run the following command:</p> <pre><code>curl --request POST \"https://gitlab.com/api/v4/projects/YOUR_PROJECT_ID/merge_requests/YOUR_MERGE_REQUEST/notes\" \\\n     --header \"PRIVATE-TOKEN: glpat-YOUR_VALUE_HERE\" \\\n     --form \"body=Token permission test.\"\n</code></pre> <p>You must plug in your own values for <code>YOUR_PROJECT_ID</code>, <code>YOUR_MERGE_REQUEST</code>, and <code>glpat-YOUR_VALUE_HERE</code>. If you are self-hosting GitLab, the URL will be different. If the above command results in a comment being created, your token is valid. </p> <p>Also note that GitLab requires a Paraxial.io version of <code>2.7.8</code> or higher. Run the following to test if your install is working locally:</p> <pre><code>mix paraxial.scan --gitlab_app --gitlab_token $GITLAB_KEY --gitlab_project $CI_PROJECT_ID --merge_request $CI_MERGE_REQUEST_IID \n</code></pre> <p>Ensure you have an open merge request and replace <code>$GITLAB_KEY, $CI_PROJECT_ID, and $CI_MERGE_REQUEST_IID</code> with the values for your current project. </p> <p>If you are using self-hosted GitLab add the <code>--gitlab_url</code> flag:</p> <pre><code>mix paraxial.scan --gitlab_app --gitlab_token $GITLAB_KEY --gitlab_project $CI_PROJECT_ID --merge_request $CI_MERGE_REQUEST_IID --gitlab_url https://gitlab.example.com\n</code></pre> <p>Replace <code>https://gitlab.example.com</code> with your instance URL. If a comment is created by Paraxial.io, you are using the correct version and can continue. </p> <p>Now to run Paraxial.io in CI/CD. For the current project, go to:</p> <p>Settings &gt; CI/CD &gt; Variables</p> <p>And set the following:</p> <ul> <li><code>PARAXIAL_API_KEY</code> (found in app.paraxial.io, under your site's settings)</li> <li><code>GITLAB_KEY</code> (the token you just created)</li> </ul> <p></p>"},{"location":"elixir/gitlab_app/#3-gitlab-cicd","title":"3. GitLab CI/CD","text":"<p>Create the following in your project root directory:</p> <p><code>.gitlab-ci.yml</code></p> <pre><code># The workflow must have a merge request for Paraxial.io to comment on\nworkflow:\n  rules:\n    - if: $CI_MERGE_REQUEST_IID\n\nimage: elixir:latest\n\nservices:\n  - postgres:latest\nvariables:\n  POSTGRES_DB: carafe\n  POSTGRES_HOST: postgres\n  POSTGRES_USER: postgres\n  POSTGRES_PASSWORD: \"postgres\"\n  MIX_ENV: \"test\"\n\nbefore_script:\n  - mix local.rebar --force\n  - mix local.hex --force\n  - mix deps.get\n\nmix:\n  script:\n    - mix test\n    - mix paraxial.scan --gitlab_app --gitlab_token $GITLAB_KEY --gitlab_project $CI_PROJECT_ID --merge_request $CI_MERGE_REQUEST_IID  --sobelow-config --add-exit-code\n\ndeploy:\n  stage: deploy\n  script: echo \"Define your deployment script!\"\n  environment: production\n</code></pre> <p>Note the arguments:</p> <ul> <li><code>--gitlab_app</code>     - required to send scan results to GitLab</li> <li><code>--gitlab_token</code>   - the personal, project, or group access token</li> <li><code>--gitlab_project</code> - the GitLab project ID</li> <li><code>--merge_request</code>  - merge request IID </li> </ul> <p>The following optional arguments are included:</p> <ul> <li><code>--sobelow-config</code> - use the <code>.sobelow-conf</code> file in the project</li> <li><code>--add-exit-code</code>  - return non-zero exit code if findings exist, to fail CI/CD </li> </ul> <p>If you are using the self hosted version of GitLab, add the flag:</p> <p><code>--gitlab_url https://gitlab.example.com</code></p> <p>For example:</p> <p><code>mix paraxial.scan --sobelow-config --gitlab_app --gitlab_token $GITLAB_KEY --gitlab_project $CI_PROJECT_ID --merge_request $CI_MERGE_REQUEST_IID --gitlab_url https://gitlab.paraxial.io --add-exit-code</code></p> <p>If you are using the cloud version of GitLab, this flag is not needed. </p> <p>Now open a merge request and observe the findings from Paraxial.io:</p> <p></p> <p>If no issues are found, you will get a green check comment:</p> <p></p>"},{"location":"elixir/install/","title":"Agent Quick Install","text":""},{"location":"elixir/install/#introduction","title":"Introduction","text":"<p>This is a concise list of steps to install the Paraxial.io agent. It is intended for users who have already read the Getting Started guide. </p>"},{"location":"elixir/install/#mix-install-paraxial","title":"Mix install paraxial","text":"<pre><code>{:paraxial, \"~&gt; 2.8.4\"}\n</code></pre>"},{"location":"elixir/install/#config","title":"Config","text":"<pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),  # Required\n  fetch_cloud_ips: true,                                 # Optional, set to true if using Paraxial.AssignCloudIP or Paraxial.BlockCloudIP\n  exploit_guard: :monitor                                # Optional, set to :monitor or :block \n</code></pre> <p>Set the <code>PARAXIAL_API_KEY</code> environment variable to keep this secret out of source code. </p>"},{"location":"elixir/install/#edit-endpointex","title":"Edit <code>endpoint.ex</code>","text":"<p>For bot defense:</p> <pre><code>  plug RemoteIp\n  plug Paraxial.AllowedPlug\n  plug Paraxial.RecordPlug\n  plug HavanaWeb.Router\n  plug Paraxial.RecordPlug\n</code></pre>"},{"location":"elixir/install/#optional-only-send-events-for-specific-routes","title":"(Optional) Only send events for specific routes","text":"<p>To only collect data for specific routes, set your configuration at compile time to the code below, by editing your <code>config/dev.exs</code>, <code>config/test.exs</code>, and <code>config/prod.exs</code> files. </p> <p>Do NOT set <code>only:</code> or <code>except:</code> at runtime, the agent uses metaprogramming to generate code at compile time. If you set <code>only:</code> or <code>except:</code> at runtime, the agent will ignore the config and send data for all routes. As of <code>2.0.0</code>, you will get an error (see below).</p> <p>To have the agent only send data to the backend for the following:</p> <ul> <li>GET /users/log_in</li> <li>POST /users/log_in</li> <li>GET /users/:id/settings</li> </ul> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),  \n  ... \n  only: [\n    %{path: \"/users/log_in\", method: \"GET\"},\n    %{path: \"/users/log_in\", method: \"POST\"},\n    %{path: \"/users/:id/settings\", method: \"POST\"}\n  ]\n</code></pre> <p>To send events for all routes, except the following:</p> <ul> <li>GET /health_check</li> <li>GET /users/:id/status</li> </ul> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),  \n  ... \n  except: [\n    %{path: \"/health_check\", method: \"GET\"},\n    %{path: \"/users/:id/status\", method: \"GET\"}\n  ]\n</code></pre> <p>After changing <code>only/except</code> in your compile time configuration, you must run:</p> <pre><code>mix deps.compile paraxial --force\n</code></pre> <p>Or you will get an error:</p> <pre><code>@ air % mix phx.server\nERROR! the application :paraxial has a different value set for key :except during runtime compared to compile time. Since this application environment entry was marked as compile time, this difference can lead to different behaviour than expected:\n\n  * Compile time value was not set\n  * Runtime value was set to: [%{method: \"GET\", path: \"/health_check\"}, %{method: \"GET\", path: \"/users/:id/status\"}]\n\nTo fix this error, you might:\n\n  * Make the runtime value match the compile time one\n\n  * Recompile your project. If the misconfigured application is a dependency, you may need to run \"mix deps.compile paraxial --force\"\n\n  * Alternatively, you can disable this check. If you are using releases, you can set :validate_compile_env to false in your release configuration. If you are using Mix to start your system, you can pass the --no-validate-compile-env flag\n</code></pre>"},{"location":"elixir/install/#optional-assigns-paraxial_current_user","title":"(Optional) Assigns paraxial_current_user","text":"<pre><code>defmodule HavanaWeb.Router do\n  ...\n  pipeline :browser do\n    ...\n    plug Paraxial.CurrentUserPlug\n  end\n</code></pre> <p>Note: This essentially does <code>assign(conn, :paraxial_current_user, conn.assigns.current_user.email)</code>, so make sure <code>conn.assigns.current_user.email</code> exists. </p>"},{"location":"elixir/install/#optional-send-paraxial_login_user_name-via-assigns","title":"(Optional) Send :paraxial_login_user_name via assigns","text":"<p>In your application code, determine how a user's login attempt flows through the code. You are looking for the line right before the user's provided email and password are checked against the database. Once you find that location, re-write the conn with: </p> <p><code>conn = assign(conn, :paraxial_login_user_name, email)</code></p> <p>Where <code>email</code> is the user provided string for a login attempt. </p>"},{"location":"elixir/install/#optional-send-login-success-true-or-false","title":"(Optional) Send login success true or false","text":"<p><code>conn = assign(conn, :paraxial_login_success, false)</code></p>"},{"location":"elixir/start/","title":"Getting started with Paraxial.io (Elixir, Free Tier)","text":"<p>This tutorial is a step-by-step guide to setup Paraxial.io with the open source vulnerable Elixir application Potion Shop. It will walk through creating an account, installing the agent, and getting results flowing to the backend. Functionality is limited in the free tier, for example you cannot send HTTP traffic to the Paraxial.io backend for analysis.</p>"},{"location":"elixir/start/#free-tier-limits","title":"Free Tier Limits","text":"<ol> <li>Maximum of 1 Site.</li> <li>You cannot invite users to a Site.</li> <li>No bot defense related features.</li> <li>Limit of 5 scans per site, per month.</li> <li>No automated network scanning (daily, weekly)</li> </ol> <p>If you have questions about Paraxial, need enterprise support, or would like to upgrade your plan, email <code>support@paraxial.io</code>.</p>"},{"location":"elixir/start/#1-create-your-paraxialio-account","title":"1. Create your Paraxial.io account","text":"<p>Go to https://app.paraxial.io/ in your web browser. Create a new account. You will receive a confirmation email, use it to confirm your account and sign in. You have no sites at this point. </p>"},{"location":"elixir/start/#2-create-your-site","title":"2. Create your site","text":"<p>Create a new site, but pick a different domain besides <code>local_potion_shop</code>. Note that the <code>domain</code> is really treated as a comment by Paraxial.io, you can put any value you want here, it does not have to be a valid URL and no HTTP requests are ever sent to it.</p> <p></p> <p></p>"},{"location":"elixir/start/#3-install-the-agent","title":"3. Install the agent","text":"<p>This guide assumes you are installing Paraxial.io in the open source vulnerable Elixir app Potion Shop.</p> <pre><code>% git clone https://github.com/securityelixir/potion_shop.git\nCloning into 'potion_shop'...\n...\n\n% cd potion_shop\n</code></pre> <p>Open <code>mix.exs</code>. If you see the line:</p> <pre><code>  {:sobelow, \"~&gt; 0.13\", only: [:dev, :test], runtime: false}\n</code></pre> <p>Delete it. The Paraxial agent will install Sobelow as a dependency, deleting this line avoids a conflict. </p> <p>Add the following to your <code>mix.exs</code> file:</p> <pre><code>{:paraxial, \"~&gt; 2.8.4\"}\n</code></pre> <p>Then run: </p> <pre><code>mix deps.get\n\nmix ecto.setup \n\nmix phx.server\n</code></pre> <p>Check to make sure the running application matches the screenshot in the Potion Shop README before you continue. - https://github.com/securityelixir/potion_shop</p>"},{"location":"elixir/start/#4-configure-the-dev-environment","title":"4. Configure the dev environment","text":"<p>Open <code>config/dev.exs</code> and add:</p> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\")\n</code></pre> <p>Set the <code>PARAXIAL_API_KEY</code> environment variable to keep this secret out of source code. </p> <p>The API key's value is found under \"Site Settings\", it looks like a UUID. To keep it out of source code for this tutorial, you can do:</p> <p><code>export PARAXIAL_API_KEY=your_value_here</code></p>"},{"location":"elixir/start/#5-install-the-paraxial-agent","title":"5. Install the Paraxial agent","text":"<p>Run: </p> <p><code>mix deps.get</code> - Install the agent</p> <p><code>mix paraxial.scan</code> - Runs Code Scans and License Scan</p> <p><code>mix phx.server</code> - Runs app audit. If you are not in a Phoenix application, you can also do <code>iex -S mix</code></p> <p>When running these commands watch out for errors and warnings. Common issues:</p> <ol> <li>Did you put the configuration in the <code>config/dev.exs</code> file?</li> <li>Is <code>PARAXIAL_API_KEY</code> set correctly? Sometimes there is a trailing newline and that breaks things.</li> <li>Is <code>paraxial_url</code> set to <code>\"https://app.paraxial.io\"</code>, with quotes?</li> <li>What mix environment is your application running in? Is it dev? </li> <li>If the API key is being read, but the scan upload fails, is it the correct value?</li> </ol> <p>Customer support is available to help, email <code>support@paraxial.io</code>. </p> <p>If everything worked you should see the following screen:</p> <p></p>"},{"location":"elixir/started/","title":"Getting Started with Paraxial.io for Elixir","text":"<p>This guide will walk you through setup for Paraxial.io. Most features require a paid account. If you are on the free tier, email <code>support@paraxial.io</code> to request a 2 week free trial. </p> <p>Application Secure</p> <ul> <li>Asset management - A full inventory of all your Elixir projects</li> <li>Network Scans - Determine which ports are open on your web server</li> <li>Code Scans - Source code (SAST) and dependency (SCA) scanning </li> <li>GitHub or GitLab App - Get security feedback in your pull request</li> <li>License Scans - Determine which open source licenses are in use</li> <li>App Audit - A runtime inventory of all your dependency versions</li> <li>Exploit Guard - runtime detection of deserialization exploits</li> </ul> <p></p> <p>Bot Defense</p> <ul> <li>Ingesting HTTP traffic</li> <li>Rate limiting - Ban IPs that do too many login attempts</li> <li>Honeypots - Ban IPs that submit a fake form</li> <li>Blocking data center/cloud IP attacks</li> <li>Banning bots scanning for <code>.php</code> routes</li> </ul>"},{"location":"elixir/started/#sign-up-create-your-first-site","title":"Sign Up, Create Your First Site","text":"<p>Create your account here - https://app.paraxial.io/users/register</p> <p>Confirm your email and create your first site:</p> <p></p> <p><code>Site Name</code> - Cannot contain spaces.</p> <p><code>Timezone</code> - Select the timezone where you are located</p> <p><code>Environment</code> - Where is this application deployed? You should create one site for each environment.</p> <p><code>Web facing</code> - Does this application face the public internet? This is a label set by the account owner, not detected by the agent. </p> <p><code>PII (Personal Identifiable Information)</code> - Does this application handle sensitive user data? This is a label set by the account owner, Paraxial.io cannot access PII. </p>"},{"location":"elixir/started/#asset-management","title":"Asset Management","text":"<p>Now that your site is created you can get a better sense of how Asset Management Works:</p> <p></p> <p>This view displayed:</p> <ul> <li>Each site you have created</li> <li>The environment, PII, and Web Facing values</li> <li>The current vulnerabilities (via code scans)</li> <li>When the last code scan took place</li> </ul> <p>The foundation of a security program is understanding what assets need to be protected. With this view, you can quickly get a sense of what security controls are currently active across your organization. </p>"},{"location":"elixir/started/#network-scans","title":"Network Scans","text":"<p>Before starting with network scans, determine if your application is hosted on a server where you control which ports are exposed to the public internet, or a Platform as a Service (PaaS).</p> <p>PaaS: Heroku, Gigalixir, Render, Fly.io, Railway</p> <p>VPS: AWS, GCP, Hetzner, Azure, Digital Ocean </p> <p>If your hosting provider is in the \"PaaS\" group, network scanning is not applicable to your application, because you don't have access to the host operating system and network configuration. If you are on a VPS, then using network scanning is recommended. See the documentation page for Network Scans to start.</p>"},{"location":"elixir/started/#code-scans","title":"Code Scans","text":"<p>There are three popular security tools for ensuring the security of Phoenix applications:</p> <ol> <li><code>Sobelow</code>, for static analysis of source code for vulnerabilities, https://github.com/nccgroup/sobelow </li> <li><code>deps.audit</code>, to scan a project's dependencies for vulnerabilities, https://github.com/mirego/mix_audit</li> <li><code>hex.audit</code>, to scan for dependencies that have been marked as retired, https://hexdocs.pm/hex/Mix.Tasks.Hex.Audit.html </li> </ol> <p>It may seem straightforward to integrate these tools into your existing CI/CD pipeline, but consider the following questions:</p> <ol> <li>When was the last time the scan ran successfully? </li> <li>Do you have a record of when all these scans happened?</li> <li>Did the numbers of vulnerabilities increase or decrease compared to the previous scans? </li> <li>How do you view the findings of the most recent scan? Of a scan from 3 months ago? </li> </ol> <p>With the Paraxial.io agent, you now have access to the command: </p> <pre><code>mix paraxial.scan\n</code></pre> <p>This will run <code>Sobelow</code>, <code>deps.audit</code>, and <code>hex.audit</code> on your application, then upload the results to the Paraxial.io backend, so you have a detailed record for compliance audits (SOC 2, HIPAA, ISO). </p> <p></p> <p>Install the Paraxial.io Agent in Your Project</p> <p>Now it is time to install the Paraxial.io agent. The agent is written in Elixir, and installed as a Hex dependency - https://hex.pm/packages/paraxial</p> <p><code>mix.exs</code></p> <pre><code>{:paraxial, \"~&gt; 2.8.4\"}\n</code></pre> <pre><code>mix deps.get\n</code></pre> <p>The package is installed as a normal Elixir dependency. Once you confirm the install was successful, go to your site in the web interface of app.paraxial.io -&gt; Site Settings -&gt; Site API Key. </p> <p>With the private API key, configure your project:</p> <p><code>config/dev.exs</code></p> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\")\n</code></pre> <p>Then in your terminal:</p> <pre><code>% export PARAXIAL_API_KEY=your_secret_here\n% mix deps.compile\n% mix paraxial.scan\n11:49:15.586 [info] [Paraxial] v2.8.3, scan starting\n\n11:49:15.587 [info] [Paraxial] API key found, scan results will be uploaded\n...\n11:49:17.619 [info] [Paraxial] Scan written successfully. UUID bbef9230-8d31-4bba-8148-91358a3207f9\n</code></pre> <p>For information about how to use a Sobelow configuration file, ignore findings, and an FAQ, see the Code Scans documentation.</p>"},{"location":"elixir/started/#github-or-gitlab-app","title":"GitHub or GitLab App","text":"<p>Developers in your organization can run <code>mix paraxial.scan</code> locally to ensure their code does not have any security problems before opening a pull request. This is beneficial because CI/CD takes several minutes to run, while the mix command takes only a few seconds. </p> <p>A good practice is to scan each new pull request in your organization for security issues. Paraxial.io has a GitHub and GitLab app which does the following:</p> <ol> <li>Create a comment on each new pull request highlighting any security issues</li> <li>Ranks the issues by severity (remote code execution and SQL injection are critical, for example)</li> <li>Provides developers with detailed instructions on how to verify and fix the problem </li> </ol> <p>The GitHub/GitLab App runs in CI, so these security checks will be part of your team's everyday workflow. For information about getting setup, see the GitHub App or GitLab App page. </p>"},{"location":"elixir/started/#license-scans-and-app-audit","title":"License Scans and App Audit","text":"<p>When you ran <code>mix paraxial.scan</code>, which is a compile time operation, an inventory of all your dependencies, the version of each, and their open source license is sent to the Paraxial.io backend. </p> <p>The App Audit feature is similar, in that it also generates a list of all the dependencies, the difference is:</p> <p><code>License Scan</code> - Compile time, dependency versions, with license information</p> <p><code>App Audit</code> - Runtime, dependency versions </p> <p>Why this redundancy? Sometimes the dependencies specified in <code>mix.lock</code> do not match what is actually deployed in production. In a scenario where there is a major vulnerability in a core library such as plug, cowboy, or phoenix, it is a good idea to use App Audit.</p> <p>Consider CVE-2025-32433, an Unauthenticated Remote Code Execution in Erlang/OTP SSH. When CVE-2025-32433 was announced Paraxial.io customers were able to use App Audit to determine if the Erlang SSH library was running in their application, and Network Scans to determine if the service was exposed via an open port to the public internet. </p> <p>To get App Audit data for your current site, start your application with a valid Paraxial API key:</p> <pre><code>@ potion_shop % mix phx.server   \n[info] [Paraxial] v2.8.3 URL and API key found. Agent will be started\n...\n[info] Running CarafeWeb.Endpoint with cowboy 2.13.0 at 127.0.0.1:4000 (http)\n[info] Access CarafeWeb.Endpoint at http://localhost:4000\n...\n[info] [Paraxial] App Audit upload success\n</code></pre>"},{"location":"elixir/started/#exploit-guard","title":"Exploit Guard","text":"<p>Exploit Guard provides runtime application self protection for your application. To use Exploit Guard, ensure your agent version is &gt;= <code>2.4.0</code>.</p> <p>Exploit Guard has two configurations, <code>:monitor</code> or <code>:block</code></p> <p><code>monitor</code> - No action will be taken, this is the \"read only\" option.</p> <p><code>block</code> - The process where the new function was created will be killed.</p> <p>When Exploit Guard detects a new function is created at runtime, an alert will be sent to your Paraxial.io site. If you have a webhook configured, a POST request will be sent. </p> <p>Example:</p> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),\n  exploit_guard: :monitor  # This value can be :monitor or :block\n</code></pre> <p>To trigger an Exploit Guard event for testing, start your application with:</p> <pre><code>@ potion_shop % iex -S mix       \n...\n[info] [Paraxial] Exploit Guard set to monitor mode\n[info] [Paraxial] App Audit upload success\niex(2)&gt;  a = :erlang.term_to_binary(fn x -&gt; x end)\n&lt;&lt;131, 112, 0, 0, 0, 161, 1, 201, 188, 156, 143, 16, 126, 173, 32, 90, 79, 205,\n  206, 160, 193, 177, 248, 0, 0, 0, 42, 0, 0, 0, 1, 119, 8, 101, 114, 108, 95,\n  101, 118, 97, 108, 97, 42, 98, 6, 77, 228, 228, 88, 119, ...&gt;&gt;\niex(3)&gt; :erlang.binary_to_term(a)      \n#Function&lt;42.105768164/1 in :erl_eval.expr/6&gt;\n[alert] [Paraxial] Exploit behavior detected, binary_to_term created function\n[alert] [Paraxial] Exploit info: \n13:15:19.168277 &lt;0.478.0&gt; erlang:binary_to_term(&lt;&lt;131,112,0,0,0,161,1,201, ...\n[alert] [Paraxial] Monitor mode active, no action taken\n[alert] [Paraxial] Exploit behavior detected, binary_to_term created function\n[alert] [Paraxial] Exploit info: \n13:15:19.177085 &lt;0.478.0&gt; erlang:binary_to_term/1 --&gt; #Fun&lt;erl_eval.42.105768164&gt;\n[alert] [Paraxial] Monitor mode active, no action taken\n</code></pre> <p>Visit <code>Site &gt; Exploit Guard</code> to view the event. </p> <p>The implementation of Exploit Guard is open source, see Exploit Guard: Open Source Runtime Application Self Protection for Elixir.</p> <p>For more information on how RCE exploits work in Elixir, see the article Elixir/Phoenix Security: Remote Code Execution and Serialisation.</p>"},{"location":"elixir/started/#application-secure-end","title":"Application Secure End","text":"<p>This concludes the high level overview of Paraxial.io Application Secure. All the features specified above are included in your Application Secure Plan. Further Reading:</p> <p>Code Scans Documentation</p> <ul> <li>Full list of all the flags</li> <li>How to ignore findings, including dependencies</li> <li>How to setup with an Umbrella application</li> </ul> <p></p>"},{"location":"elixir/started/#bot-defense","title":"Bot Defense","text":"<p>To get started with bot defense, click here.</p>"},{"location":"elixir/started_bot/","title":"Getting Started with Paraxial.io for Elixir - Bot Defense","text":"<p>This guide is for Paraxial.io Bot Defense. A paid account is required. If you are on the free tier, email <code>support@paraxial.io</code> to request a 2 week free trial.</p> <p>You will setup the following:</p> <ul> <li>Ingesting HTTP traffic</li> <li>Rate limiting - Ban IPs that do too many login attempts</li> <li>Honeypots - Ban IPs that submit a fake form</li> <li>Banning bots scanning for <code>.php</code> routes</li> <li>Blocking data center/cloud IP attacks</li> </ul>"},{"location":"elixir/started_bot/#create-account-and-install-paraxialio","title":"Create Account and Install Paraxial.io","text":"<p>You can skip this section if you have already installed Paraxial.io by following the Getting Started guide for Application Secure.</p> <p>Create your account here - https://app.paraxial.io/users/register</p> <p>Confirm your email and create your first site:</p> <p></p> <p><code>Site Name</code> - Cannot contain spaces.</p> <p><code>Timezone</code> - Select the timezone where you are located</p> <p><code>Environment</code> - Where is this application deployed? You should create one site for each environment.</p> <p><code>Web facing</code> - Does this application face the public internet? This is a label set by the account owner, not detected by the agent. </p> <p><code>PII (Personal Identifiable Information)</code> - Does this application handle sensitive user data? This is a label set by the account owner, Paraxial.io cannot access PII. </p> <p>Install the Paraxial.io agent. The agent is written in Elixir, and installed as a Hex dependency - https://hex.pm/packages/paraxial</p> <p><code>mix.exs</code></p> <pre><code>{:paraxial, \"~&gt; 2.8.4\"}\n</code></pre> <pre><code>mix deps.get\n</code></pre> <p>The package is installed as a normal Elixir dependency. Once you confirm the install was successful, go to your site in the web interface of app.paraxial.io -&gt; Site Settings -&gt; Site API Key. </p> <p>With the private API key, configure your project:</p> <p><code>config/dev.exs</code></p> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\")\n</code></pre>"},{"location":"elixir/started_bot/#ingest-http-traffic","title":"Ingest HTTP Traffic","text":"<p>Create a new Git branch, then run <code>mix test</code> before making any code changes. If any tests are failing, make a note of that fact before you continue with the install. </p> <p>Run:</p> <pre><code>mix paraxial.scan\n</code></pre> <p>To ensure you have the dependency installed and API configured correctly. If the scan runs and uploads successfully, continue. </p> <p>Now that you are on a new branch, and have confirmed that your install is working, add the following plugs to record HTTP traffic:</p> <p><code>endpoint.ex</code></p> <pre><code>  # plug RemoteIp                  # This plug is optional, only needed if you are behind a proxy\n  plug Paraxial.AllowedPlug        # Determine if an incoming request is allowed based on ban list\n  plug Paraxial.RecordPlug         # To record requests that do not match the router\n  plug YourProjectNameWeb.Router   # Change to your own project name\n  plug Paraxial.RecordPlug         # To record requests that did match the router\n</code></pre> <p>Note that <code>plug Paraxial.RecordPlug</code> appearing twice is intentional.</p> <p>Paraxial.io uses the value of <code>conn.remote_ip</code> for bot defense. If you are behind a proxy, every HTTP request will have the same IP. This can be fixed via the RemoteIP plug. For example, <code>plug RemoteIp, headers: [\"fly-client-ip\"]</code> is specific to fly.io deployments. Your configuration may be different. </p> <p>Now start your application, make sure the configuration is correct, and send some local HTTP requests:</p> <pre><code>@ potion_shop % mix phx.server\nGenerated carafe app\n[info] [Paraxial] v2.8.3 URL and API key found. Agent will be started  &lt;-- This is what you want to see\n[info] Access CarafeWeb.Endpoint at http://localhost:4000\n[info] GET /\n[info] Sent 200 in 58ms\n[info] GET /\n[info] Sent 200 in 3ms\n</code></pre> <p>The requests will show as from localhost:</p> <p></p> <p>If your application has a large amount of HTTP traffic (&gt; 100,000 HTTP requests/month), you can restrict sending traffic to only specific routes. For detailed instructions see the Bot Defense documentation page.</p>"},{"location":"elixir/started_bot/#rate-limiting-with-rules","title":"Rate Limiting with Rules","text":"<p>Now that you have the appropriate plug in place (<code>plug Paraxial.AllowedPlug</code>), define the following bot defense rule:</p> <p>If an IP sends more than 5 login attempts in 10 seconds, ban for 1 week:</p> <p></p> <p>You can use a similar route in your own application during testing. Now send a few HTTP requests by refreshing the page and observe a rule event has been created:</p> <p></p> <p>By default, the Paraxial.io agent does not send user emails to the backend. You can get the history of login attempts for an IP address, instructions in the Bot Defense docs.</p>"},{"location":"elixir/started_bot/#html-honeypot","title":"HTML Honeypot","text":"<p>Find a controller that does not require auth, create the following action:</p> <pre><code># Values for second argument (length) are :hour, :day, :week, :infinity\n\ndef honeypot_ban(conn, _params) do\n  Paraxial.ban_ip(conn.remote_ip, :week, \"Triggered honeypot form, ban for 1 week\")\n  json(conn, %{ok: \"system online\"})\nend\n</code></pre> <p>In your router, find a scope that goes through the :browser pipeline (for CSRF protection) and does not require auth, for example:</p> <pre><code>  scope \"/\", ParaxWeb do\n    pipe_through :browser\n\n    post \"/customer\", PageController, :honeypot_ban\n  end\n</code></pre> <p>Create the form, with CSRF protection:</p> <pre><code>&lt;%= form_for @conn, Routes.page_path(@conn, :honeypot_ban), [style: \"display:none !important\"], fn f -&gt; %&gt;\n  &lt;%= text_input f, :email, tabindex: -1 %&gt;\n  &lt;%= text_input f, :password, tabindex: -1 %&gt;\n  &lt;%= submit \"Register\" %&gt;\n&lt;% end %&gt;\n</code></pre> <p>LiveView version:</p> <pre><code>def render(assigns) do\n  ~H\"\"\"\n  &lt;.form for={@form} id=\"customer_form\" action={~p\"/customer\"} style=\"display:none !important\"&gt;\n    &lt;.input field={@form[:email]} type=\"email\" label=\"Email\" tabindex=\"-1\" /&gt;\n    &lt;.input field={@form[:password]} type=\"password\" label=\"Password\" tabindex=\"-1\" /&gt;\n    &lt;button&gt;Register&lt;/button&gt;\n  &lt;/.form&gt;\n  ...\n</code></pre> <pre><code># @form needs a value\ndef mount(_params, _session, socket) do\n  form = to_form(%{}, as: \"user\")\n  {:ok, assign(socket, form: form)}\nend\n</code></pre> <p>Note that you have have to change the values here, for example your application may not have a <code>PageController</code>, you will have to substitute with a public controller action.</p> <p>To test your implementation, use inspect element in your browser to remove <code>display:none !important</code> on the rendered page, then submit the form. If you get banned, the setup was successful. </p>"},{"location":"elixir/started_bot/#banning-malicious-clients-doing-php-requests","title":"Banning Malicious Clients Doing .php Requests","text":"<p>In a Phoenix app you may want to define a plug with some custom logic, for example if an IP sends a request ending in <code>.php</code>, this is a strong signal they are not a real user and should be banned. You could write this plug yourself, or use the one included with Paraxial.io. </p> <p><code>endpoint.ex</code></p> <pre><code>  plug RemoteIp, headers: [\"fly-client-ip\"]    # This is specific to fly.io\n  plug Paraxial.AllowedPlug                    # Required to enforce Paraxial.io bans\n  plug Paraxial.RecordPlug                     # Optional, requires paid account\n  plug Paraxial.PHPAttackPlug, length: :week   # Place before the router\n  plug HavanaWeb.Router                        # The value \"HavanaWeb\" will be different in your own project\n  plug Paraxial.RecordPlug                     # Optional, requires paid account\n</code></pre> <pre><code>defmodule Paraxial.PHPAttackPlug do\n  @moduledoc \"\"\"\n  Plug to ban IPs sending requests that end in .php\n\n  Most Elixir and Phoenix applications do not have routes ending in .php,\n  so this is a strong signal an IP is malicious. The default ban length\n  is one hour, this can be configured when setting the plug in your\n  endpoint.ex file:\n\n    plug Paraxial.PHPAttackPlug, length: :week\n    plug HavanaWeb.Router  # Your application name will be different\n\n  Valid options for :length are :hour, :day, :week, :infinity\n  \"\"\"\n  import Plug.Conn\n  require Logger\n\n  @valid_lengths [:hour, :day, :week, :infinity]\n  @default_length :hour\n  @ban_message \"Sent request ending in .php\"\n\n  def init(opts) do\n    length = Keyword.get(opts, :length, @default_length)\n\n    if length in @valid_lengths do\n      opts\n    else\n      Logger.warning(\"[Paraxial] Invalid option for Paraxial.PHPAttackPlug: #{length}, using #{@default_length}\")\n      [length: @default_length]\n    end\n  end\n\n  def call(conn, opts) do\n    if php_request?(conn.request_path) do\n      length = Keyword.get(opts, :length)\n\n      Task.start(fn -&gt;\n        Paraxial.ban_ip(conn.remote_ip, length, @ban_message)\n      end)\n\n      conn\n      |&gt; halt()\n      |&gt; send_resp(403, Jason.encode!(%{\"error\" =&gt; \"banned\"}))\n    else\n      conn\n    end\n  end\n\n  defp php_request?(path) do\n    String.ends_with?(String.downcase(path), \".php\")\n  end\nend\n</code></pre> <p>The above code is the source for <code>plug Paraxial.PHPAttackPlug</code>. Below is an example of a ban notification from the Paraxial.io Slack App:</p> <p></p> <p>Now you may want to use a custom plug with your own logic in Elixir code. For this, Paraxial.io gives you the function:</p> <p><code>Paraxial.ban_ip(ip, length, message)</code></p> <pre><code>  Ban an IP address, both locally and on the Paraxial.io backend.\n\n  Returns the result of an HTTP request, for example:\n\n  {:ok, \"ban created\"} - returned on successful ban\n\n  {:error, \"ban not created\"} - returned if you attempt to ban an IP that is already banned\n\n  {:error, \"invalid length, valid options are :hour, :day, :week, :infinity\"}\n\n  If you are using this function in a blocking content, call with Task.start, https://hexdocs.pm/elixir/1.12/Task.html#start/1\n\n  - `ip` - Format should match conn.remote_ip, which is a tuple, \n           {192, 168, 1, 1} or {8193, 3512, 34211, 0, 0, 35374, 880, 29492}\n  - `length` - Valid options are :hour, :day, :week, :infinity\n  - `message` - A string comment, for example \"Submitted honeypot HTML form\"\n</code></pre> <p>See the example above for how to use this function. It does trigger an HTTP request, so using a Task is helpful to prevent blocking. </p> <pre><code>Task.start(fn -&gt;\n  Paraxial.ban_ip(conn.remote_ip, length, @ban_message)\nend)\n</code></pre>"},{"location":"elixir/started_bot/#data-center-and-cloud-ips","title":"Data Center and Cloud IPs","text":"<p>By default, several Cloud hosting IP ranges are defined in the Paraxial agent:</p> <ul> <li>AWS</li> <li>Azure</li> <li>GCP</li> <li>Digital Ocean</li> <li>Oracle</li> </ul> <p>This is useful because a login request coming from a rented Cloud IP server is most likely a bot, and should be blocked. To make this data available locally in your agent, ensure <code>fetch_cloud_ips: true</code> is set:</p> <pre><code>config :paraxial,\n  paraxial_api_key: System.get_env(\"PARAXIAL_API_KEY\"),\n  fetch_cloud_ips: true\n</code></pre> <p>There are two plugs related to Cloud IP matching:</p> <p><code>Paraxial.AssignCloudIP</code> -  If the <code>remote_ip</code> of an incoming request matching a cloud provider IP address, this plug will add metadata to the conn via an assigns. For example, if a conn's remote_ip matches aws, this plug will do <code>assigns(conn, :paraxial_cloud_ip, :aws)</code>. Use this if your application has branching logic based on if an incoming <code>conn.remote_ip</code> is from a rented server.</p> <p><code>Paraxial.BlockCloudIP</code> - When a conn matches a cloud provider IP, the assign is updated and the conn is halted, with a 404 response sent to the client. Use this to block cloud IPs, for example in your router's authentication pipeline.</p> <p></p> <p>Will Paraxial.BlockCloudIP block Google's Crawler?</p> <p>No, Google's Cloud Platform is hosted on a different IP range from Googlebot. Google will still be able to index your site, you are only blocking requests from GCP servers that anyone can rent. </p> <p></p> <p>What if I want to allow a specific Cloud IP? For example a client has a cloud-hosted VPN with a cloud IP.</p> <p>Add the IP address to your site's Allow List, and it will no longer be blocked by <code>Paraxial.BlockCloudIP</code> </p>"},{"location":"elixir/started_bot/#further-reading","title":"Further Reading","text":"<p>See the documentation page for Bot Defense for detailed information about:</p> <ul> <li>How rules defined in the web interface work</li> <li>Rate limiting on LiveView websocket channels</li> <li>Assigns values such as <code>paraxial_login_success</code>, <code>:paraxial_login_user_name</code>, and <code>:paraxial_current_user</code></li> </ul>"},{"location":"elixir/why/","title":"Why Use Paraxial.io for Elixir","text":"<p>CVE-2025-32433, an Unauthenticated Remote Code Execution in Erlang/OTP SSH, is a good example which demonstrates why the deep feature set of Paraxial.io is necessary to deal with real exploits becoming public:</p> <ul> <li>Static analysis of source code cannot detect the vulnerability</li> <li>Checking the project's lockfile will not detect it</li> </ul> <p>Most SAST/SCA tools stop their coverage there. With Paraxial.io:</p> <ul> <li>The App Audit feature shows if the Erlang SSH library is loaded</li> <li>The Network Scan feature can detect if the SSH service is exposed to the public internet</li> </ul> <p>Further reading:</p> <p>What the Critical Erlang SSH Vulnerability Means for Elixir Developers</p> <p>Why VC Funded Security Firms Miss a Critical Vulnerability</p> <p>If your Elixir application is critical to your business and exposed to the public internet, it is recommended that you use all the Paraxial.io features. Below are additional scenarios that are highly likely to occur. </p> <p>An Elixir/Phoenix web application that is exposed to the public internet will be attacked. This is the reality of the modern web, any software you expose must have safeguards. Security is a large and complicated subject, if you are thinking \"I don't even know where to start with security\", do not worry, you have come to the right place. </p> <p>Consider a SaaS business, Black Cat Projects, which makes project management software. Below are examples of security incidents and how Paraxial.io would prevent each one:</p> <p></p>"},{"location":"elixir/why/#lack-of-asset-management-leads-to-forgotten-app-being-compromised","title":"Lack of asset management leads to forgotten app being compromised","text":"<p>Black Cat Projects has two codebases: <code>havana</code>, the main application, and <code>ticker</code>, a microservice that pulls metrics from the database for a dashboard. The company focuses all the security efforts on <code>havana</code>, doing security reviews, having it pentested by a 3rd party firm, and keeping the software up to date. <code>ticker</code> is neglected, and it runs an outdated version of Elixir and Phoenix. </p> <p><code>ticker</code> contains a vulnerability that is trivial to exploit, a command injection that leads to full server compromise. One day an attacker notices this microservice, hacks into it, and gets SSH access to the EC2 host. The network is not segmented well, meaning the attacker is able to further compromise the production server, and steal the entire database, causing a breach. </p> <p>How would Paraxial.io prevent this?</p> <p>All your internet-facing web applications should be catalogued in Paraxial.io:</p> <p></p> <p>Paraxial.io would communicate that <code>ticker</code> was not being scanned for security issues. Even if nobody was logging into Paraxial.io on a frequent basis, the weekly email report would show that an internet-facing project was not being checked for security issues. </p> <p></p>"},{"location":"elixir/why/#exposed-postgresql-endpoint-leads-to-data-breach","title":"Exposed PostgreSQL endpoint leads to data breach","text":"<p>The recommended best practice for using a database in production is:</p> <p><code>User HTTP request ---&gt; App Server &lt;--- private connection ---&gt; Database server</code></p> <p>Where the database server is never exposed to the public internet. The benefit of this architecture is that even if there is a security problem with PostgreSQL, it will most likely require the database server to be public for an attacker to exploit it, so isolating the server reduces this risk.</p> <p>However, you can just run PostgreSQL on the application server. Now imagine a misconfiguration, where the PostgreSQL port 5432 is open to the public internet, and the db server has a weak password. A bad guy scans for the server, is able to brute force the password (it was something weak like <code>postgres</code>), and steals the entire database.</p> <p>How would Paraxial.io prevent this?</p> <p>The Network Scans feature would detect port 5432 is open to the public internet. While the engineering team at Black Cat Projects thought this port was closed, it is always better to verify. Paraxial.io automatically scans the server daily or weekly, so if a port is opened by accident it will be detected. </p> <p></p> <p>As you can see from the above scan, 5432 is closed, but having 3306 and 22 exposed to the public internet (with password authentication for SSH) is not ideal. </p> <p>For more information about server security, see the article Security Best Practices for Deploying Rails 8 on Linux with Kamal, the guidance is applicable to Elixir as well. </p> <p></p>"},{"location":"elixir/why/#vulnerable-dependency-leads-to-remote-code-execution-rce","title":"Vulnerable dependency leads to remote code execution (RCE)","text":"<p>Black Cat Projects decides to use GitHub's dependabot for dependency security in their Elixir projects. After all, it seems compatible: </p> <p></p> <p>There is a critical vulnerability here that dependabot cannot detect because dependency graph does not support Elixir.</p> <p>In the above screenshot dependabot generated a lot of noise about non-security related upgrades, but misses the security issue:</p> <p></p> <p>The paginator library is vulnerable to remote code execution (RCE), which is the worst case scenario for a web application. An attacker can use this vulnerability to get the equivalent of production SSH access. In a sense, dependabot was worse than nothing, because it gives a false sense of security while failing to notify users of critical security issues. </p> <p>How would Paraxial.io prevent this?</p> <p>Paraxial.io will only notify you when there is a security issue in your dependencies: </p> <p></p> <p>Paraxial.io does not spam you with non-security related upgrade info the way dependabot does.</p> <p></p>"},{"location":"elixir/why/#remote-code-execution-via-erlangbinary_to_term","title":"Remote code execution via :erlang.binary_to_term","text":"<p>Consider the following code:</p> <pre><code>defmodule CarafeWeb.PotionController do\n  use CarafeWeb, :controller\n\n    def vendors(conn, %{\"cursor\" =&gt; c}) do\n    cursor_bin = Base.decode64!(c)\n    cursor = :erlang.binary_to_term(cursor_bin, [:safe])\n    cursor_list = Enum.to_list(cursor)\n    first = Enum.min(cursor_list)\n    last = Enum.max(cursor_list)\n\n    vendors = Vendors.get_vendors()\n    rv = Enum.slice(vendors, cursor)\n    render(conn, \"vendors.html\", vendors: rv, first: first, last: last)\n  end\n</code></pre> <p>What is the impact of this vulnerability? </p> <p>If you answered \"remote code execution via <code>:erlang.binary_to_term</code>, you're correct! The <code>[:safe]</code> option is misleading, it only prevents the creation of new atoms, it does not stop the creation of executable terms. The impact of this vulnerability is that an attacker can execute shell commands on the server, leading to the equivalent of production SSH access, causing a data breach. </p> <p>How would Paraxial.io prevent this?</p> <p>The Paraxial.io GitHub App can run Sobelow, the static code analyzer, on each new pull request via CI/CD. On it's own the Sobelow finding does not explain how severe this problem is:</p> <pre><code>Confidence: high_confidence\nFile: lib/carafe_web/controllers/potion_controller.ex\nLine: 29\nType: Misc.BinToTerm: Unsafe `binary_to_term`\nVariable: cursor_bin\n</code></pre> <p>Paraxial.io gives a detailed explanation of the vulnerability, with advice on how to fix it:</p> <p></p> <p></p> <p>If you would like to learn more about this type of vulnerability, see Elixir/Phoenix Security: Remote Code Execution and Serialisation. </p> <p></p>"},{"location":"elixir/why/#user-accounts-compromised-via-credential-stuffing","title":"User accounts compromised via credential stuffing","text":"<p>Does your application have a login form, where users enter their email and password? If it does, you will have to deal with bots performing credential stuffing attacks. The idea is that most people re-use passwords across sites, and data breaches are common enough that user's old passwords can be found online. For example, a user signed up for a golf forum with the credentials <code>jack@example.com, golf1234567</code> several years ago. The forum was hacked, and that credential is now public. One day you receive thousands of login attempts per hour, where each attempt is for a different account. The bad guy is searching for users who re-used their password. </p> <p>How would Paraxial.io prevent this?</p> <p>The bot defense feature of Paraxial.io gives you several tools to stop this attack:</p> <ul> <li> <p>Rate limiting </p> </li> <li> <p>Banning malicious bots (sending requests for .php endpoints)</p> </li> <li> <p>Banning requests from data center IPs</p> </li> <li> <p>Honeypot HTML forms</p> </li> </ul> <p>See Getting Started - Bot Defense for more information. </p>"},{"location":"ruby/CHANGELOG/","title":"Paraxial.io Ruby Agent Changelog","text":"<p>The Paraxial.io Ruby Agent is hosted on RubyGems - https://rubygems.org/gems/paraxial</p>"},{"location":"ruby/CHANGELOG/#145","title":"<code>1.4.5</code>","text":"<ul> <li>If site is on the free tier, do not waste bandwidth with HTTP tick requests. </li> </ul>"},{"location":"ruby/CHANGELOG/#144","title":"<code>1.4.4</code>","text":"<ul> <li>If <code>.paraxial-rubocop.yml</code> does not exist when running <code>paraxial scan</code>, it will now automatically be created and configured to allow Rubocop to scan erb files. </li> </ul>"},{"location":"ruby/CHANGELOG/#143","title":"<code>1.4.3</code>","text":"<ul> <li>Improve cross site request forgery (CSRF) detection in Rubocop.</li> </ul>"},{"location":"ruby/CHANGELOG/#142","title":"<code>1.4.2</code>","text":"<ul> <li>Better error handling when user on free tier is rate limited from Code Scans.</li> </ul>"},{"location":"ruby/CHANGELOG/#141","title":"<code>1.4.1</code>","text":"<ul> <li>Add the <code>config.disable_http_tick = true</code> option to disable HTTP requests when bot defense is not in use. </li> </ul>"},{"location":"ruby/CHANGELOG/#140","title":"<code>1.4.0</code>","text":"<ul> <li>Fixed a bug where <code>Paraxial.block_cloud_ip</code> would block an IP on the allow list.</li> <li>Now an IP on the allow list will always be able to make a connection. For example, you have a VPN hosted in AWS and always want to allow traffic from it. </li> </ul>"},{"location":"ruby/CHANGELOG/#131","title":"<code>1.3.1</code>","text":"<ul> <li>Improve runtime checks to prevent the agent from starting during rails commands.</li> </ul>"},{"location":"ruby/CHANGELOG/#130","title":"<code>1.3.0</code>","text":"<ul> <li>Add the <code>Paraxial::PHPAttackMiddleware</code>, a pre-defined way to ban malicious clients requesting <code>.php</code> routes. </li> </ul>"},{"location":"ruby/CHANGELOG/#120","title":"<code>1.2.0</code>","text":"<ul> <li>Add the <code>.paraxial.yml</code> file. Users can define <code>ignore-gems:</code> to exclude gems from vulnerability scannings. </li> </ul>"},{"location":"ruby/CHANGELOG/#110","title":"<code>1.1.0</code>","text":"<ul> <li>Configure Paraxial.io RuboCop settings with <code>.paraxial-rubocop.yml</code> instead of the old <code>.rubocop.yml</code></li> </ul>"},{"location":"ruby/CHANGELOG/#102","title":"<code>1.0.2</code>","text":"<ul> <li>Fix bug in SQL cop for code scans</li> </ul>"},{"location":"ruby/CHANGELOG/#101","title":"<code>1.0.1</code>","text":"<ul> <li>Add <code>--debug-rubocop</code> flag for <code>paraxial scan</code>, runs rubocop in debug mode</li> </ul>"},{"location":"ruby/bot_defense/","title":"Bot Defense","text":"<p>Paid Feature</p> <p>This is a paid Paraxial.io feature. It is not available in the free tier.</p> <p>This page is a tutorial to send HTTP events to the Paraxial.io backend. You should complete the Getting Started guide first. </p>"},{"location":"ruby/bot_defense/#middleware","title":"Middleware","text":"<p>Update the middleware you already have with the <code>Paraxial.record(request, status)</code> method:</p> <p><code>lib/middleware/ip_filter_middleware.rb</code></p> <pre><code>require 'paraxial'\n\nclass IpFilterMiddleware\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    request = ActionDispatch::Request.new(env)\n\n    Paraxial.block_cloud_ip(request, ['/login'])\n    Paraxial.req_allowed?(request)\n\n    if env['paraxial.deny']\n      status = 403\n      Paraxial.record(request, status)\n      [status, {'Content-Type' =&gt; 'text/plain'}, ['Forbidden']]\n    else\n      status, headers, response = @app.call(env)\n      Paraxial.record(request, status)\n      [status, headers, response]\n    end\n  end\nend\n</code></pre> <p>This does the following:</p> <ol> <li>Creates a new request via middleware.</li> <li>If the request is coming from a cloud server IP, and matches the <code>/login</code> route, do not allow the request. Note that your own authentication route may be different.</li> <li>Check if the request is allowed, setting the <code>env</code> value.</li> <li>If the request was denied, set it to 403 and return forbidden. If it is allowed, pass it through. In both cases the request will be recorded and sent to the Paraxial.io backend.</li> </ol> <p>Now update the application file to ensure the middleware is loaded:</p> <p><code>config/application.rb</code></p> <pre><code>require_relative 'boot'\nrequire 'rails/all'\n\nBundler.require(*Rails.groups)\n\nmodule SampleApp\n  class Application &lt; Rails::Application\n    # Initialize configuration defaults for originally generated Rails version.\n    config.load_defaults 7.0\n\n    # [Paraxial.io] Add these lines to ensure IpFilterMiddleware is loaded\n    Dir[Rails.root.join('lib', 'middleware', '*.{rb}')].each { |file| require file }\n    config.middleware.use IpFilterMiddleware\n\n  end\nend\n</code></pre> <p>Ensure you have the <code>PARAXIAL_API_KEY</code> value set and start rails:</p> <pre><code>@ sample_app % rails s               \n=&gt; Booting Puma\n=&gt; Rails 7.1.3.4 application starting in development \n=&gt; Run `bin/rails server --help` for more startup options\n[Paraxial] Agent starting...\n[Paraxial] API key detected, agent starting\n[Paraxial] Exploit Guard, no configuration exists, will not run\n[Paraxial] Cloud IPs set\nPuma starting in single mode...\n* Puma version: 6.4.2 (ruby 3.1.2-p20) (\"The Eagle of Durango\")\n*  Min threads: 5\n*  Max threads: 5\n*  Environment: development\n*          PID: 36781\n* Listening on http://127.0.0.1:3000\n* Listening on http://[::1]:3000\nUse Ctrl-C to stop\n</code></pre> <p>Load the web page in your browser. Then, go to your Paraxial.io site:</p> <p></p> <p>If you can see requests in HTTP Tail, it is working.</p>"},{"location":"ruby/bot_defense/#disable-http-requests-when-not-using-bot-defense","title":"Disable HTTP Requests when not using Bot Defense","text":"<p>WARNING</p> <p>If you are using bot defense, there is no need to set <code>disable_http_tick</code>. If you set this value to <code>true</code>, it will break bot defense. The only reason to set this value is true is if you are not using bot defense and want to disable HTTP requests to save bandwidth. </p> <p>Bot defense sends an HTTP request to the Paraxial.io backend every few seconds to update the allow and ban lists. If you are not using bot defense and would like to disable the HTTP request, ensure you are on Paraxial Ruby Gem <code>1.4.1</code> or later and add the following in your project: </p> <p><code>config/initializers/paraxial.rb</code></p> <pre><code>Paraxial.configure do |config|\n  # Only do this if you are NOT using bot defense. It will break IP banning.\n  config.disable_http_tick = true \nend\n</code></pre>"},{"location":"ruby/code_scans/","title":"Code Scans","text":""},{"location":"ruby/code_scans/#ignoring-rubocop-findings","title":"Ignoring RuboCop Findings","text":"<p>Paraxial.io uses RuboCop for static analysis. If a finding is a false positive, there are two ways to flag this:</p> <ol> <li>Via a code comment</li> <li>In the <code>.paraxial-rubocop.yml</code> file, which follows the normal RuboCop configuration settings.</li> </ol> <pre><code># rubocop:disable Paraxial/SQL\ndef show\n  User.find_by_sql(\"select * from users WHERE id = #{params[:id]} \")\nend \n</code></pre> <p>If the function has multiple findings, separate the cop name with a comma:</p> <pre><code># rubocop:disable Paraxial/SQL, Paraxial/System\ndef show\n  system(params[:id])\n  User.find_by_sql(\"select * from users WHERE id = #{params[:id]} \")\nend \n</code></pre> <p>Some cops are built into RuboCop, and others and written by Paraxial.io. The full list: </p> <ul> <li>Paraxial/Constantize</li> <li>Paraxial/CSRF</li> <li>Paraxial/HTMLSafe</li> <li>Paraxial/Raw</li> <li>Paraxial/Send</li> <li>Paraxial/SQL</li> <li>Paraxial/System</li> <li>Security/Eval</li> <li>Security/IoMethods</li> <li>Security/JSONLoad</li> <li>Security/MarshalLoad</li> <li>Security/Open</li> <li>Security/YAMLLoad</li> </ul> <p>If you want to disable a cop on a specific file, or disable it across the entire project, <code>.paraxial-rubocop.yml</code> is the best way to do that. </p> <p><code>.paraxial-rubocop.yml</code></p> <pre><code>require:\n  - rubocop-erb\n\nParaxial/Constantize:\n  Enabled: true\n  Exclude:\n    - 'app/controllers/users_controller.rb'\n\nParaxial/HTMLSafe:\n  Enabled: true\n  Exclude:\n    - 'app/views/static_pages/home.html.erb'\n\nParaxial/Send:\n  Enabled: false\n</code></pre>"},{"location":"ruby/code_scans/#ignoring-vulnerable-gems","title":"Ignoring Vulnerable Gems","text":"<p>To ignore a vulnerable Gem in the scan results use the <code>.paraxial.yml</code> file:</p> <p><code>.paraxial.yml</code></p> <pre><code>ignore-gems:\n- bootstrap-sass\n- puma             \n\n</code></pre>"},{"location":"ruby/php_attack/","title":"PHPAttackMiddleware","text":"<p>This feature requires Paraxial.io for Ruby version <code>1.3.0</code> or higher.</p> <p>Most Ruby on Rails applications do not have routes ending in <code>.php</code>, so if an IP does this, that is a strong signal they are malicious and should be banned. Consider the following middleware:</p> <pre><code>module Paraxial\n  class PHPAttackMiddleware\n    VALID_LENGTHS = [:hour, :day, :week, :infinity]\n\n    def initialize(app, length: :hour)\n      @app = app\n      if VALID_LENGTHS.include?(length)\n        @ban_length = length\n      else\n        puts \"[Paraxial] PHPAttackMiddleware invalid ban length: #{length}, using hour\"\n        @ban_length = :hour\n      end\n    end\n\n    def call(env)\n      request = ActionDispatch::Request.new(env)\n\n      if request.path.downcase.end_with?('.php')\n        Paraxial.ban_ip_msg(request.remote_ip, @ban_length, \"Sent request ending in .php\")\n        # Return a 404 response if the request path ends with '.php'\n        [404, { 'Content-Type' =&gt; 'text/plain' }, ['Not Found']]\n      else\n        # Pass the request to the next middleware or the application\n        @app.call(env)\n      end\n    end\n  end\n</code></pre> <p>This is the source code for the <code>Paraxial::PHPAttackMiddleware</code>. Example usage:</p> <p><code>config/application.rb</code></p> <pre><code>module SampleApp\n  class Application &lt; Rails::Application\n    # Initialize configuration defaults for originally generated Rails version.\n    config.load_defaults 7.0\n\n    Dir[Rails.root.join('lib', 'middleware', '*.{rb}')].each { |file| require file }\n    # IpFilterMiddleware is defined in your application\n    # on a paid plan, it contains Paraxial.record(request, status)\n    # Putting it first allows you to see the banned requests in the \n    # Paraxial.io backend\n    config.middleware.use IpFilterMiddleware\n    config.middleware.use Paraxial::PHPAttackMiddleware, length: :week\n  end\nend\n</code></pre> <p>With the above configuration, any IP that sends a request ending in <code>.php</code> will be banned. Below is an example of a ban notification from the Paraxial.io Slack App:</p> <p></p> <p>If you would like to implement your own middleware logic for banning an IP address, use the function:</p> <p><code>Paraxial.ban_ip_msg(ip, ban_length, message)</code></p> <p>With the following arguments:</p> <pre><code>ip - string, same format as `request.remote_ip` above\nban_length - atom, options are :hour, :day, :week, and :infinity \nmessage - string, the reason the IP was banned\n</code></pre>"},{"location":"ruby/start/","title":"Getting started with Paraxial.io (Ruby)","text":"<p>This tutorial is a step-by-step guide to setup Paraxial.io with a Ruby on Rails application. It will walk through creating an account, installing the agent, and getting results flowing to the backend. Functionality is limited in the free tier, for example you cannot send HTTP traffic to the Paraxial.io backend for analysis.</p>"},{"location":"ruby/start/#free-tier-limits","title":"Free Tier Limits","text":"<ol> <li>Maximum of 1 Site.</li> <li>You cannot invite users to a Site.</li> <li>No Bot Defense</li> <li>Limit of 5 scans per site, per month.</li> <li>No automated network scanning (daily, weekly)</li> </ol> <p>If you have questions about Paraxial, need enterprise support, or would like to upgrade your plan, email <code>support@paraxial.io</code>.</p>"},{"location":"ruby/start/#1-create-your-paraxialio-account","title":"1. Create your Paraxial.io account","text":"<p>Go to https://app.paraxial.io/ in your web browser. Create a new account. You will receive a confirmation email, use it to confirm your account and sign in. You have no sites at this point. </p>"},{"location":"ruby/start/#2-create-your-site","title":"2. Create your site","text":"<p>Create a new site, but pick a different domain besides <code>sample_app</code>. Note that the <code>domain</code> is really treated as a comment by Paraxial.io, you can put any value you want here, it does not have to be a valid URL and no HTTP requests are ever sent to it.</p> <p></p> <p></p>"},{"location":"ruby/start/#3-sample-app-install","title":"3. Sample App install","text":"<p>This section is to setup the reference sample app for the Ruby on Rails Tutorial (7th edition) by Michael Hartl. If you are installing Paraxial.io in your own project you can skip this section.</p> <p>GitHub - https://github.com/learnenough/rails_tutorial_sample_app_7th_ed</p> <pre><code>% git clone https://github.com/learnenough/rails_tutorial_sample_app_7th_ed \n% cd rails_tutorial_sample_app_7th_ed/\n\nGemfile\n% gem \"rails\",                      \"7.0.4\" # bump to 7.0.5 for Apple M1 CPU\n% rm -rf Gemfile.lock \n\n% bundle \n% rails db:migrate\n% rails db:seed\n% rails server\n</code></pre>"},{"location":"ruby/start/#4-install-paraxialio","title":"4. Install Paraxial.io","text":"<p>Paraxial.io for Ruby is hosted on RubyGems - https://rubygems.org/gems/paraxial</p> <p>Current Ruby version: <code>1.4.5</code></p> <p><code>Gemfile</code></p> <pre><code>...\ngem 'paraxial', '~&gt; 1.4.5'\n\n...\n</code></pre> <p>Find your API key in \"Site Settings\". </p> <p><code>export PARAXIAL_API_KEY=your_key_here</code></p> <p>Create <code>.paraxial-rubocop.yml</code> and add:</p> <pre><code>% cat .paraxial-rubocop.yml\nrequire:\n- rubocop-erb\n</code></pre> <p>This is so Paraxial.io can scan ERB files for security issues.</p> <p>Start your application:</p> <p><code>rails s</code></p> <p>Then check your site page:</p> <p></p> <p>You should see data for libraries and open source licenses. </p> <p>Now run a scan:</p> <pre><code>% paraxial scan\n[Paraxial] v1.1.0 Scan starting...\n[Paraxial] .paraxial-rubocop.yml is valid, .erb files will be scanned.\n\n[Paraxial] Scan count: 11\n\n(Gemfile.lock) actionpack: Possible XSS via User Supplied Values to redirect_to - 7.0.5\n- Title: actionpack: Possible XSS via User Supplied Values to redirect_to\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 6.1.7.4, &gt;= 7.0.5.1\n\n(Gemfile.lock) rubygem-actionpack: Possible XSS on translation helpers - 7.0.5\n- Title: rubygem-actionpack: Possible XSS on translation helpers\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 7.0.8, &gt;= 7.0.8.1, &gt;= 7.1.3.1\n\n(Gemfile.lock) rubygem-actionpack: Missing security headers in Action Pack on non-HTML responses - 7.0.5\n- Title: rubygem-actionpack: Missing security headers in Action Pack on non-HTML responses\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 6.1.7, &gt;= 6.1.7.8, ~&gt; 7.0.8, &gt;= 7.0.8.4, ~&gt; 7.1.3, &gt;= 7.1.3.4, &gt;= 7.2.0.beta2\n\n(Gemfile.lock) Arbitrary Code Execution Vulnerability in Trix Editor included in ActionText - 7.0.5\n- Title: Arbitrary Code Execution Vulnerability in Trix Editor included in ActionText\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 7.0.8.3, &gt;= 7.1.3.3\n\n(Gemfile.lock) rubygem-activestorage: Possible Sensitive Session Information Leak in Active Storage - 7.0.5\n- Title: rubygem-activestorage: Possible Sensitive Session Information Leak in Active Storage\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 6.1.7, &gt;= 6.1.7.7, &gt;= 7.0.8.1\n\n(Gemfile.lock) rubygem-activesupport: File Disclosure of Locally Encrypted Files - 7.0.5\n- Title: rubygem-activesupport: File Disclosure of Locally Encrypted Files\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 6.1.7, &gt;= 6.1.7.5, &gt;= 7.0.7.1\n\n(Gemfile.lock) Bootstrap Cross-Site Scripting (XSS) vulnerability - 3.4.1\n- Title: Bootstrap Cross-Site Scripting (XSS) vulnerability\n- Installed Version: 3.4.1\n- Fixed Version: \n\n(Gemfile.lock) rubygem-puma: HTTP request smuggling when parsing chunked transfer encoding bodies and zero-length content-length headers - 5.6.4\n- Title: rubygem-puma: HTTP request smuggling when parsing chunked transfer encoding bodies and zero-length content-length headers\n- Installed Version: 5.6.4\n- Fixed Version: ~&gt; 5.6.7, &gt;= 6.3.1\n\n(Gemfile.lock) rubygem-puma: HTTP request smuggling when parsing chunked Transfer-Encoding Bodies - 5.6.4\n- Title: rubygem-puma: HTTP request smuggling when parsing chunked Transfer-Encoding Bodies\n- Installed Version: 5.6.4\n- Fixed Version: ~&gt; 5.6.8, &gt;= 6.4.2\n\n(Gemfile.lock) rubygem-actionpack: Possible XSS on translation helpers - 7.0.5\n- Title: rubygem-actionpack: Possible XSS on translation helpers\n- Installed Version: 7.0.5\n- Fixed Version: 7.0.8.1, 7.1.3.1\n\n(Rubocop) CSRF, no protect_from_forgery in ApplicationController.\n- Path: app/controllers/application_controller.rb\n- Line: 1\n\n(Rubocop) `send` causes remote code execution if called on user input.\n- Path: app/models/user.rb\n- Line: 49\n\n[Paraxial] Scan UUID your_value_here\n[Paraxial] Scan URL your_url_here\n</code></pre> <p></p>"},{"location":"ruby/start/#5-github-app","title":"5. GitHub App","text":"<p>The Paraxial.io App can be installed in an organization or individual account. </p> <p>GitHub Marketplace - https://github.com/marketplace/paraxial-io</p> <p></p> <p>Note the install_id of <code>45554672</code>. Your value will be different. Make a note of this value somewhere, you will need it later.</p> <p>The Paraxial.io Github App is compatible with all CI/CD pipelines. We will be using a Github Action in this example. The following is required:</p> <ol> <li>Paraxial.io App Install ID (<code>45554672</code> in this example, your value will be different)</li> <li>Repo Owner</li> <li>Repo Name</li> <li>Pull Request number</li> </ol> <p>The dynamic values should be accessible in your CI environment. </p> <p>Put the Paraxial.io API key in GitHub Actions Secrets</p> <p>This secret key is found in \"Site Settings\" in the Paraxial.io web interface. </p> <p> </p> <p>Configure the GitHub Action</p> <p>Before continuing, answer the following questions:</p> <p></p> <p>Q: What is the name of your repo's primary branch? (It is probably <code>master</code> or <code>main</code>) </p> <p>If your repo's branch is different, replace the \"branches\" value.</p> <p>Q: What is your Paraxial.io Github App Install ID? </p> <p>See the section above </p> <p></p> <p>GitHub Action: </p> <pre><code>% mkdir -p .github/workflows\n% touch .github/workflows/paraxial.yml\n</code></pre> <pre><code>name: Paraxial.io Application Secure\n\non:\n  push:\n    branches: [ \"main\" ]\n  pull_request:\n    branches: [ \"main\" ]\n\npermissions:\n  contents: read\n\njobs:\n  build:\n\n    name: Build and test\n    runs-on: ubuntu-latest\n\n    env:\n      PARAXIAL_API_KEY: ${{ secrets.PARAXIAL_API_KEY }}\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up Ruby\n      uses: ruby/setup-ruby@v1 \n      with:\n        ruby-version: '3.1.2' \n\n    - name: Install dependencies\n      run: bundle install\n\n    - name: Get Github Repo Name\n      run: echo \"REPO_NAME=$(echo ${{ github.repository }} | cut -d'/' -f2)\" &gt;&gt; $GITHUB_ENV\n\n    - name: Paraxial.io Scan, pull request does not exists\n      if: \"${{ github.event.number == '' }}\"\n      run: |\n        paraxial scan\n\n    - name: Paraxial.io Scan, pull request exists \n      if: \"${{ github.event.number != '' }}\"\n      run: |\n        paraxial scan --github_app \\\n          --install_id YOUR_VALUE_HERE \\\n          --repo_owner ${{ github.repository_owner }} \\\n          --repo_name ${{ env.REPO_NAME }} \\\n          --pr_number ${{ github.event.number }} \\\n          --exit-code \n</code></pre> <p>The flag <code>--exit-code</code> will cause the CI/CD run to fail if findings are detected by returning an exit code of 1. This can be used to block pull requests that contain security issues. </p> <p>Example of a successful run in GitHub actions:</p> <pre><code>Run paraxial scan --github_app \\\n  paraxial scan --github_app \\\n    --install_id 45233668 \\\n    --repo_owner realcorvus \\\n    --repo_name sample_app2 \\\n    --pr_number 1\n\n  shell: /usr/bin/bash -e {0}\n  env:\n    PARAXIAL_API_KEY: ***\n    REPO_NAME: sample_app2\n[Paraxial] v1.1.0 Scan starting...\n[Paraxial] .paraxial-rubocop.yml is valid, .erb files will be scanned.\n\n[Paraxial] Scan count: 12\n\n(Gemfile.lock) actionpack: Possible XSS via User Supplied Values to redirect_to - 7.0.5\n- Title: actionpack: Possible XSS via User Supplied Values to redirect_to\n- Installed Version: 7.0.5\n- Fixed Version: ~&gt; 6.1.7.4, &gt;= 7.0.5.1\n\n(findings omitted for space)\n\n(Rubocop) `send` causes remote code execution if called on user input.\n- Path: app/models/user.rb\n- Line: 49\n\n[Paraxial] Scan UUID 5bc90764-4d20-4330-ad94-73246fcf4f51\n[Paraxial] Scan URL https://app.paraxial.io/site/sample_app/scans\n[Paraxial] GitHub hash: {\n  \"installation_id\": 45233668,\n  \"repository_owner\": \"realcorvus\",\n  \"repository_name\": \"sample_app2\",\n  \"pull_request_number\": 1,\n  \"scan_uuid\": \"5bc90764-4d20-4330-ad94-73246fcf4f51\",\n  \"api_key\": \"REDACTED\"\n}\n[Paraxial] parax_uri response: {\"ok\":\"Comment created successfully!\"}\n[Paraxial] https://github.com/realcorvus/sample_app2/pull/1\n</code></pre> <p>To use the Paraxial.io GitHub App, open a pull request:</p> <p></p>"},{"location":"ruby/start/#6-bot-defense-honeypot-form","title":"6. Bot Defense, Honeypot Form","text":"<p>A simple and effective technique for stopping bots is to render a fake HTML form on your website, not visible to normal users, but only visible to bots. A real user will never submit this form, but bots often automatically submit HTML forms, making this an effective technique for banning malicious clients. With Paraxial.io:</p> <p><code>lib/middleware/ip_filter_middleware.rb</code></p> <pre><code>require 'paraxial'\n\nclass IpFilterMiddleware\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    request = ActionDispatch::Request.new(env)\n    Paraxial.req_allowed?(request)\n\n    if env['paraxial.deny']\n      [403, {'Content-Type' =&gt; 'text/plain'}, ['Forbidden']]\n    else\n      @app.call(env)\n    end\n  end\nend\n</code></pre> <p>Ensure the middleware is loaded:</p> <p><code>config/application.rb</code></p> <pre><code>require_relative 'boot'\nrequire 'rails/all'\n\n# Require the gems listed in Gemfile, including any gems\n# you've limited to :test, :development, or :production.\nBundler.require(*Rails.groups)\n\nmodule SampleApp\n  class Application &lt; Rails::Application\n    # Initialize configuration defaults for originally generated Rails version.\n    config.load_defaults 7.0\n\n    # *** ADD THESE TWO LINES ***\n    Dir[Rails.root.join('lib', 'middleware', '*.{rb}')].each { |file| require file }\n    config.middleware.use IpFilterMiddleware\n  end\nend\n</code></pre> <p><code>Paraxial.req_allowed?</code> synchronizes with your backend, meaning any IPs placed on the ban list or allow list through the web interface will be stored locally, and used to determine the result of this function call. </p> <p>Now create the fake HTML form:</p> <pre><code>&lt;%= form_with url: '/customer_info', method: :post, html: { style: \"display:none !important\" } do |form| %&gt;\n  &lt;%= form.email_field :email, tabindex: -1 %&gt;\n  &lt;%= form.password_field :password, tabindex: -1 %&gt;\n  &lt;%= form.submit \"Submit\" %&gt;\n&lt;% end %&gt;\n</code></pre> <p>The styling is important, this form will not be visible to normal users. </p> <p>Create a route for <code>/customer_info</code>: </p> <p><code>config/routes.rb</code></p> <pre><code>Rails.application.routes.draw do\n  post '/customer_info', to: 'static_pages#bot'\nend\n</code></pre> <p>Now create a matching controller action:</p> <p><code>app/controllers/static_pages_controller.rb</code></p> <pre><code>class StaticPagesController &lt; ApplicationController\n  ... \n\n  def bot\n    # The second argument is the ban length, options are:\n    # :hour, :day, :week, and :infinity\n    Paraxial.honeypot_ban(request.remote_ip, :infinity)\n    render plain: \"ok\"\n  end\nend\n</code></pre> <p>To test if your setup is working, you can use \"inspect element\" on the page to view the form and delete the styling code, so you can submit it manually:</p> <p></p> <p></p> <p></p> <p>After submitting the form, refresh the page and you should be banned:</p> <p></p> <p>Then check your site page to view the ban:</p> <p></p>"},{"location":"ruby/start/#7-bot-defense-cloud-ips","title":"7. Bot Defense, Cloud IPs","text":"<p>\"Limit the number of login attempts for one IP address to 5 in a 30 second period\" is a standard rule for many web applications, and makes sense from the perspective of a site owner dealing with malicious credential stuffing. With the rise of cloud computing, it has become much easier for an attacker to access thousands of different IP addresses, for free, to bypass IP based blocking.</p> <p>AWS API Gateway is a service that handling incoming traffic for a web application, such as HTTP requests, and then triggers some application functionality. The important point for attackers is that the gateway can be pointed at a victim web application, so that when the attacker sends traffic to the gateway, it is proxied through an AWS server, changing the IP address. David Yesland from Rhino Security describes this technique in a blog post, and introduces a Burp Suite extension which can be used to proxy traffic through AWS.</p> <p>Blog post - https://rhinosecuritylabs.com/aws/bypassing-ip-based-blocking-aws/</p> <p>In your own application, there may be endpoints where you expect bot traffic, for example API endpoints. For a web application with authentication pages that are only intended to be used by human users, blocking traffic from major cloud providers (AWS, GCP, Azure, etc) is an excellent security measure. </p> <p>The Paraxial.io Ruby agent stores a radix trie of these IPs locally, meaning the performance impact to check an incoming request is minimal. There is no round-trip to a server, just a fast lookup in the data structure.</p> <p>The below middleware will block cloud IP requests to the endpoints:</p> <pre><code>/login\n/signup\n</code></pre> <p>Requests from cloud IPs to all other endpoints will be allowed.</p> <p><code>lib/middleware/ip_filter_middleware.rb</code></p> <pre><code>require 'paraxial'\n\nclass IpFilterMiddleware\n  def initialize(app)\n    @app = app\n  end\n\n  def call(env)\n    request = ActionDispatch::Request.new(env)\n    Paraxial.block_cloud_ip(request, ['/login'])\n\n    if env['paraxial.deny']\n      [403, {'Content-Type' =&gt; 'text/plain'}, ['Forbidden']]\n    else\n      @app.call(env)\n    end\n  end\nend\n</code></pre>"},{"location":"ruby/start/#8-bot-defense-rate-limiting","title":"8. Bot Defense, Rate Limiting","text":"<p>Paraxial.io is compatible with your existing Ruby rate limiting, for example rack-attack: https://github.com/rack/rack-attack</p> <p><code>Gemfile</code></p> <pre><code>gem 'rack-attack', '~&gt; 6.7.0'\n</code></pre> <p></p> <p><code>config/initializers/rack_attack.rb</code></p> <pre><code># Use correct IP when behind a proxy\nclass Rack::Attack\n  class Request &lt; ::Rack::Request\n    def remote_ip\n      @remote_ip ||= ActionDispatch::Request.new(env).remote_ip\n    end\n  end\nend\n\n# The bantime of 30 seconds is to save memory, once the ban is persisted to the\n# Paraxial.io backend there is no need to store it in the RackAttack cache. \nRack::Attack.blocklist('allow2ban login scrapers') do |req|\n  Rack::Attack::Allow2Ban.filter(req.remote_ip, maxretry: 5, findtime: 10, bantime: 30) do\n    req.path == '/login'\n  end\nend\n\nActiveSupport::Notifications.subscribe(\"blocklist.rack_attack\") do |name, _start, _finish, _iid, payload|\n  # Valid options for the second argument:\n  # :hour, :day, :week, and :infinity\n  Paraxial.ban_ip_msg(payload[:request].remote_ip, :hour, \"&gt; 5 requests to /login in 10 seconds\")\nend\n</code></pre>"}]}